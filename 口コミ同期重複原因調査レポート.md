# 口コミ同期重複原因調査レポート

## 1. 同期ボタン押下から口コミ保存までの呼び出し経路

### エントリーポイント
- **Route**: `routes/web.php` の `Route::post('/reviews/sync', [ReviewsController::class, 'sync'])`
  - オペレーター用: `Route::post('/operator/reviews/sync', [ReviewsController::class, 'sync'])`
- **View**: `resources/views/reviews/index.blade.php` の同期フォーム（107行目）

### 呼び出し経路

#### パターン1: ReviewsController経由（現在の実装）
```
1. routes/web.php (46行目, 112行目)
   └─> ReviewsController::sync() (app/Http/Controllers/ReviewsController.php:257)
       └─> ReviewsController::syncReviews() (app/Http/Controllers/ReviewsController.php:451)
           └─> GoogleBusinessProfileService::listReviews() (app/Services/GoogleBusinessProfileService.php:453)
               └─> Http::withToken()->get() (Google Business Profile API v4)
           └─> Review::updateOrCreate() (app/Http/Controllers/ReviewsController.php:588)
```

#### パターン2: ReportController経由（別の実装が存在）
```
ReportController::syncReviews() (app/Http/Controllers/ReportController.php:872)
  └─> GoogleBusinessProfileService::listReviews() (app/Services/GoogleBusinessProfileService.php:453)
      └─> Http::withToken()->get() (Google Business Profile API v4)
  └─> Review::upsert() (app/Http/Controllers/ReportController.php:1237)
```

**重要**: 現在の同期ボタンは `ReviewsController::sync()` を呼び出しているが、`ReportController::syncReviews()` も存在する。どちらが実際に使われているかは、ログで確認が必要。

## 2. reviewsテーブルのschema

### テーブル定義
**Migration**: `database/migrations/2024_01_01_000001_create_reviews_table.php`

```php
Schema::create('reviews', function (Blueprint $table) {
    $table->id();
    $table->foreignId('shop_id')->constrained()->onDelete('cascade');
    $table->string('author_name');
    $table->integer('rating');
    $table->text('comment')->nullable();
    $table->datetime('create_time');
    $table->text('reply_text')->nullable();
    $table->datetime('replied_at')->nullable();
    $table->timestamps();
});
```

### 追加カラム
- **snapshot_id**: `database/migrations/2026_01_31_000004_add_snapshot_id_to_reviews_table.php`
  - `$table->foreignId('snapshot_id')->nullable()->constrained('gbp_snapshots')->onDelete('set null');`
- **gbp_review_id**: 追加されたが、migrationファイルは未確認（コードから推測）
- **update_time**: `database/migrations/2026_02_07_000003_add_update_time_to_reviews_table.php`
  - `$table->datetime('update_time')->nullable();`

### UNIQUE制約
**Migration**: `database/migrations/2026_02_07_000001_change_reviews_unique_key_to_shop_based.php`

```php
$table->unique(
    ['shop_id', 'gbp_review_id'],
    'reviews_shop_id_gbp_review_id_unique'
);
```

**重要**: UNIQUE制約は `['shop_id', 'gbp_review_id']` の組み合わせ。これにより、同じ店舗内で同じ `gbp_review_id` は1件のみ保存される。

### 全カラム一覧（推測）
- `id` (bigint, primary key)
- `shop_id` (bigint, foreign key → shops.id)
- `snapshot_id` (bigint, nullable, foreign key → gbp_snapshots.id)
- `gbp_review_id` (string, UNIQUE制約の一部)
- `author_name` (string)
- `rating` (integer)
- `comment` (text, nullable)
- `create_time` (datetime)
- `update_time` (datetime, nullable)
- `reply_text` (text, nullable)
- `replied_at` (datetime, nullable)
- `created_at` (timestamp)
- `updated_at` (timestamp)

## 3. "既に取り込んでいるか確認" の実装方式

### ReviewsController::syncReviews() の実装
**ファイル**: `app/Http/Controllers/ReviewsController.php:588`

```php
Review::updateOrCreate(
    [
        'shop_id' => $shop->id,
        'gbp_review_id' => $gbpReviewIdClean,
    ],
    [
        'snapshot_id' => $snapshotId,
        'author_name' => $authorName,
        'rating' => $rating,
        'comment' => $comment,
        'create_time' => $createTime,
        'reply_text' => $replyText,
        'replied_at' => $repliedAt,
    ]
);
```

**検索条件**: `['shop_id', 'gbp_review_id']`
- この組み合わせで既存レコードを検索
- 存在すれば更新、存在しなければ新規作成
- **問題点**: `update_time` が更新対象に含まれていない（598行目）

### ReportController::syncReviews() の実装
**ファイル**: `app/Http/Controllers/ReportController.php:1237`

```php
Review::upsert(
    $rows,
    ['shop_id', 'gbp_review_id'], // ユニークキー
    [
        'snapshot_id',
        'author_name',
        'rating',
        'comment',
        'create_time',
        'reply_text',
        'replied_at',
        'update_time',   // ← これを必ず入れる
        // 'updated_at' は除外（DBに任せる）
    ]
);
```

**検索条件**: `['shop_id', 'gbp_review_id']`
- `upsert` メソッドを使用
- ユニークキーで既存レコードを検索し、存在すれば更新、存在しなければ新規作成
- **差分判定**: 1068-1159行目で `hasChanges` をチェックし、変更がある場合のみ `$rows` に追加

## 4. APIから取得している「口コミID」の正体

### Google Business Profile API v4 のレスポンス構造
**ファイル**: `app/Services/GoogleBusinessProfileService.php:453`

```php
$url = "https://mybusiness.googleapis.com/v4/accounts/{$accountId}/locations/{$locationIdClean}/reviews";
$response = Http::withToken($accessToken)->get($url);
$data = $response->json();
$reviews = $data['reviews'] ?? [];
```

```

### レスポンス例（推測）
```json
{
  "reviews": [
    {
      "name": "accounts/100814587656903598763/locations/14533069664155190447/reviews/AbFv...",
      "reviewId": "AbFv...",
      "reviewer": {
        "displayName": "テストユーザー"
      },
      "starRating": "FIVE",
      "comment": "素晴らしい店です！",
      "createTime": "2024-01-01T10:00:00Z",
      "updateTime": "2024-01-01T10:00:00Z"
    }
  ]
}
```

### gbp_review_id の取得方法

#### ReviewsController::syncReviews()
**ファイル**: `app/Http/Controllers/ReviewsController.php:538-545`

```php
$reviewName = $reviewData['name'] ?? null;
// name の最後の要素（reviewId）のみを取得
$gbpReviewIdClean = basename($reviewName);
```

**例**: `"accounts/.../locations/.../reviews/AbFv..."` → `"AbFv..."`

#### ReportController::syncReviews()
**ファイル**: `app/Http/Controllers/ReportController.php:984-988`

```php
if (!isset($review['name'])) {
    continue;
}
$reviewId = basename($review['name']);
```

**例**: `"accounts/.../locations/.../reviews/AbFv..."` → `"AbFv..."`

### 識別子の安定性
- **`review['name']`**: Google Business Profile API v4 の標準的な識別子
- **`review['reviewId']`**: 同じ値を含む可能性があるが、コードでは `name` から `basename()` で取得
- **結論**: `gbp_review_id` は `review['name']` の最後の部分（reviewId）であり、**毎回同じ値**が返される（変動しない識別子）

## 5. 差分同期の条件

### Google Business Profile API v4 の制約
**ファイル**: `app/Services/GoogleBusinessProfileService.php:472`

```php
// 注意: GBP API v4 の reviews.list には updateTime フィルタがないため、全件取得
```

**結論**: API側では差分取得ができない。**常に全件取得**される。

### ReviewsController::syncReviews() の差分判定
**ファイル**: `app/Http/Controllers/ReviewsController.php:521-536`

```php
// 期間指定がある場合は、createTimeでフィルタリング
if ($startDate || $endDate) {
    $createTime = isset($reviewData['createTime']) ? Carbon::parse($reviewData['createTime']) : null;
    
    if ($createTime) {
        if ($startDate && $createTime->lt($startDate)) {
            continue;
        }
        if ($endDate && $createTime->gt($endDate)) {
            continue;
        }
    } else {
        // createTimeがない場合はスキップ（期間指定時）
        continue;
    }
}
```

**差分判定**: **期間指定（startDate/endDate）のみ**
- `last_synced_at` は使用していない
- `updateTime` での差分判定は行っていない
- **問題点**: 期間指定がない場合、毎回全件を `updateOrCreate` で処理するため、既存レコードも更新される

### ReportController::syncReviews() の差分判定
**ファイル**: `app/Http/Controllers/ReportController.php:903-916, 1023-1057`

```php
// 最終同期日時を取得（増分同期用）
$lastSyncedAt = $shop->last_reviews_synced_at;

// 増分同期フィルタ: 既存レコードが存在し、かつ既存のupdate_time >= APIのupdateTime の場合はスキップ
if ($existingReview) {
    $existingTime = null;
    if ($existingReview->update_time) {
        $existingTime = \Carbon\Carbon::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC');
    } elseif ($existingReview->create_time) {
        $existingTime = \Carbon\Carbon::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC');
    }
    
    if ($existingTime && $parsedUpdateTime->lte($existingTime)) {
        $shouldSkip = true;
    }
}
```

**差分判定**: `update_time` または `create_time` で比較
- 既存レコードの `update_time` >= APIの `updateTime` の場合はスキップ
- `update_time` が null の場合は `create_time` で判定
- **問題点**: `parsedUpdateTime->gt($existingTime)` が true になるケースが多発している可能性（1159行目）

### ページネーション
**ファイル**: `app/Services/GoogleBusinessProfileService.php:493`

```php
$pageCount = 1; // GBP API v4 はページネーションなし（全件返す）
```

**結論**: ページネーションは**存在しない**。APIは常に全件を返す。

## 6. 現状の問題仮説

### 仮説1: ReviewsController::syncReviews() で update_time が更新されない
**根拠**: `app/Http/Controllers/ReviewsController.php:588-602`

```php
Review::updateOrCreate(
    [
        'shop_id' => $shop->id,
        'gbp_review_id' => $gbpReviewIdClean,
    ],
    [
        'snapshot_id' => $snapshotId,
        'author_name' => $authorName,
        'rating' => $rating,
        'comment' => $comment,
        'create_time' => $createTime,
        'reply_text' => $replyText,
        'replied_at' => $repliedAt,
        // update_time が含まれていない！
    ]
);
```

**問題点**:
- `update_time` が更新対象に含まれていない
- そのため、既存レコードの `update_time` が古いままになる
- 次回同期時に `parsedUpdateTime->gt($existingTime)` が true になり、常に更新される

**影響**: 毎回全件が更新される可能性

### 仮説2: ReportController::syncReviews() で hasChanges が全件trueになる
**根拠**: `app/Http/Controllers/ReportController.php:1159`

```php
if ($parsedUpdateTime->gt($existingTime)) {
    $hasChanges = true;
}
```

**問題点**:
- `parsedUpdateTime->gt($existingTime)` が true になるケースが多発
- 原因は `Carbon::parse()` の曖昧解釈や timezone の不一致の可能性
- そのため、変更がないレビューも `$rows` に追加され、`upsert` で更新される

**影響**: 毎回全件が更新される可能性

### 仮説3: 2つの異なる実装が混在している
**根拠**: 
- `ReviewsController::syncReviews()` と `ReportController::syncReviews()` が両方存在
- 同期ボタンは `ReviewsController::sync()` を呼び出しているが、`ReportController::syncReviews()` も存在

**問題点**:
- どちらが実際に使われているか不明確
- 2つの実装で異なるロジックが適用される可能性

**影響**: 予期しない動作や重複の原因になる可能性

## 7. 重複確認用SQL

### 重複の実態確認（shop_id + gbp_review_id で重複してるか）
```sql
-- shop_id + gbp_review_id の組み合わせで重複しているレビューを検出
SELECT 
    shop_id,
    gbp_review_id,
    COUNT(*) as duplicate_count,
    GROUP_CONCAT(id ORDER BY id) as review_ids,
    MIN(created_at) as first_created,
    MAX(created_at) as last_created
FROM reviews
GROUP BY shop_id, gbp_review_id
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC, shop_id, gbp_review_id;
```

### 最新の重複例（どの口コミIDが何件に増えてるか）
```sql
-- 重複しているレビューの詳細
SELECT 
    r.id,
    r.shop_id,
    s.name as shop_name,
    r.gbp_review_id,
    r.snapshot_id,
    r.author_name,
    r.rating,
    r.create_time,
    r.update_time,
    r.created_at,
    r.updated_at
FROM reviews r
INNER JOIN shops s ON r.shop_id = s.id
WHERE (r.shop_id, r.gbp_review_id) IN (
    SELECT shop_id, gbp_review_id
    FROM reviews
    GROUP BY shop_id, gbp_review_id
    HAVING COUNT(*) > 1
)
ORDER BY r.shop_id, r.gbp_review_id, r.created_at DESC;
```

### UNIQUE制約の確認（MySQLのSHOW INDEX等）
```sql
-- reviewsテーブルのインデックス一覧
SHOW INDEX FROM reviews;

-- UNIQUE制約の確認
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    ORDINAL_POSITION
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_NAME = 'reviews'
  AND CONSTRAINT_NAME LIKE '%unique%'
ORDER BY CONSTRAINT_NAME, ORDINAL_POSITION;

-- reviews_shop_id_gbp_review_id_unique の存在確認
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    ORDINAL_POSITION
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_NAME = 'reviews'
  AND CONSTRAINT_NAME = 'reviews_shop_id_gbp_review_id_unique'
ORDER BY ORDINAL_POSITION;
```

### 追加の検証SQL
```sql
-- 同じgbp_review_idが異なるshop_idで存在するか確認
SELECT 
    gbp_review_id,
    COUNT(DISTINCT shop_id) as shop_count,
    GROUP_CONCAT(DISTINCT shop_id) as shop_ids
FROM reviews
GROUP BY gbp_review_id
HAVING COUNT(DISTINCT shop_id) > 1
ORDER BY shop_count DESC;

-- update_timeがnullのレビュー数
SELECT 
    COUNT(*) as null_update_time_count,
    COUNT(CASE WHEN update_time IS NULL THEN 1 END) as null_count,
    COUNT(CASE WHEN update_time IS NOT NULL THEN 1 END) as not_null_count
FROM reviews;

-- 最新の同期で更新されたレビュー（updated_atが最近）
SELECT 
    shop_id,
    gbp_review_id,
    update_time,
    updated_at,
    TIMESTAMPDIFF(SECOND, update_time, updated_at) as time_diff_seconds
FROM reviews
WHERE updated_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)
ORDER BY updated_at DESC
LIMIT 100;
```

## 8. 推奨される修正方針

### 修正1: ReviewsController::syncReviews() に update_time を追加
**ファイル**: `app/Http/Controllers/ReviewsController.php:588-602`

```php
Review::updateOrCreate(
    [
        'shop_id' => $shop->id,
        'gbp_review_id' => $gbpReviewIdClean,
    ],
    [
        'snapshot_id' => $snapshotId,
        'author_name' => $authorName,
        'rating' => $rating,
        'comment' => $comment,
        'create_time' => $createTime,
        'update_time' => $updateTime ?? $createTime, // ← 追加
        'reply_text' => $replyText,
        'replied_at' => $repliedAt,
    ]
);
```

### 修正2: ReportController::syncReviews() の timezone 処理を統一
**ファイル**: `app/Http/Controllers/ReportController.php:1037-1057`

既に修正済み（`Carbon::createFromFormat()` で明示的にUTCとして読む）

### 修正3: どちらの実装を使うか統一
- 同期ボタンは `ReviewsController::sync()` を呼び出している
- `ReportController::syncReviews()` は別の用途（レポート生成時？）で使われている可能性
- 実際の使用箇所を確認し、統一する

## 9. 結論

### 重複が発生する原因箇所（候補）

1. **ReviewsController::syncReviews() で update_time が更新されない**（最重要）
   - `update_time` が更新対象に含まれていない
   - 既存レコードの `update_time` が古いまま
   - 次回同期時に常に更新される

2. **ReportController::syncReviews() で hasChanges が全件trueになる**
   - `parsedUpdateTime->gt($existingTime)` が true になるケースが多発
   - timezone の不一致が原因の可能性

3. **2つの異なる実装が混在している**
   - `ReviewsController::syncReviews()` と `ReportController::syncReviews()` が両方存在
   - どちらが実際に使われているか不明確

### 次のステップ

1. **SQLで重複を確認**: 上記のSQLを実行し、実際に重複が発生しているか確認
2. **ログで使用箇所を確認**: `SYNC_REVIEWS__CODE_VERSION` ログで、どちらの実装が使われているか確認
3. **修正を実施**: 上記の修正方針に従って修正









