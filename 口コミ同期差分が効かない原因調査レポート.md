# 口コミ/写真/投稿 同期「差分が効かない」原因調査レポート

## 調査目的
shop_id=5 の口コミ同期で `existing_count=15` なのに `skipped_count=0` / `rows_to_write_count=15` / `updated_count=15` となり、毎回「全件更新扱い」になっている原因を特定する。

## 調査対象ファイル
- `app/Services/ReviewSyncService.php`
- `app/Services/GoogleBusinessProfileService.php`
- `app/Http/Controllers/ReviewsController.php` (Photo同期)
- `app/Http/Controllers/ReportController.php` (Post同期)

---

## 1. 既存レビュー lookup が当たっているかを "ログで" 証明

### 1.1 実装箇所
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 339-373（追加したログ）

### 1.2 追加したログ
```php
// REVIEWS_LOOKUP_DEBUG（最初の5件のみ）
Log::info('REVIEWS_LOOKUP_DEBUG', [
    'shop_id' => $shop->id,
    'review_index' => $lookupDebugCounter,
    'api_review_id_raw' => $reviewIdRaw,
    'api_review_id_normalized' => $reviewId,
    'existing_reviews_keys_sample' => $existingReviews->keys()->take(5)->toArray(),
    'existing_review_hit' => $existingReview !== null ? 'HIT' : 'MISS',
    'db_gbp_review_ids_sample' => $dbReviewIds,
    'db_gbp_review_ids_normalized_sample' => array_map(function($id) {
        return $this->normalizeReviewId((string)$id);
    }, $dbReviewIds),
]);
```

### 1.3 確認ポイント
- `existing_review_hit` が `HIT` か `MISS` か
- `api_review_id_normalized` と `existing_reviews_keys_sample` が一致しているか
- `db_gbp_review_ids_normalized_sample` と `api_review_id_normalized` が一致しているか

**判定基準**:
- 常に `MISS` なら → キー不一致が原因（差分以前の問題）
- `HIT` でも `rows_to_write_count` が全件なら → 時刻比較の問題

---

## 2. 時刻比較がズレて "常に更新" になってないかを "ログで" 証明

### 2.1 実装箇所
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 429-470（追加したログ）

### 2.2 追加したログ
```php
// REVIEWS_TIME_COMPARISON_DEBUG（最初の5件のみ）
Log::info('REVIEWS_TIME_COMPARISON_DEBUG', [
    'shop_id' => $shop->id,
    'review_index' => $lookupDebugCounter,
    'gbp_review_id' => $reviewId,
    'api_raw' => $apiRaw,
    'api_parsed_utc' => $gbpUpdateTime ? $gbpUpdateTime->toIso8601String() : null,
    'api_rounded' => $apiTimeRounded,
    'existing_raw' => $existingRaw ? (is_object($existingRaw) ? get_class($existingRaw) : gettype($existingRaw)) : null,
    'existing_raw_value' => $existingTimeBeforeRound,
    'existing_raw_source' => $existingRawSource,
    'existing_parsed_utc' => $existingTime ? $existingTime->toIso8601String() : null,
    'existing_rounded' => $existingTimeRounded,
    'update_time_changed' => $updateTimeChanged ?? false,
    'should_skip' => $shouldSkip,
    'reply_changed' => $replyChanged ?? false,
    'needs_update' => $needsUpdate ?? false,
    'will_add_to_rows' => ($needsUpdate ?? false),
]);
```

### 2.3 確認ポイント
- `api_parsed_utc` と `existing_parsed_utc` が同じ時刻なのに `update_time_changed=true` になっていないか
- `api_rounded` と `existing_rounded` が同じなのに `should_skip=false` になっていないか
- `existing_raw_source` が `gbp_update_time` になっているか（優先順位確認）
- `existing_raw` が Carbon インスタンスの場合、`->utc()` で直接変換しているか（再parseしていないか）

**判定基準**:
- `api_rounded` と `existing_rounded` が同じなのに `should_skip=false` → 時刻比較ロジックの問題
- `existing_raw_source` が `update_time` や `create_time` になっている → `gbp_update_time` が NULL の可能性
- `existing_raw` が Carbon で再parseしている → タイムゾーン9時間ズレの可能性

### 2.4 修正した既存時刻のパース処理
**変更前**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    $existingTimeRaw = $existingRaw->format('Y-m-d H:i:s');
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
}
```

**変更後**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    // Carbon型の場合は ->utc() で直接UTCに変換（再parseしない）
    $existingTime = CarbonImmutable::instance($existingRaw)->utc();
}
```

**理由**: 再parseするとタイムゾーンが9時間ズレる可能性があるため、直接 `->utc()` で変換するように修正。

---

## 3. "rows_to_write_count が常に fetched_count と同じ" になる構造を確認

### 3.1 rows に追加される条件
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 702-745

```php
// 変更がある場合のみ $rows に追加（needsUpdate判定を使用）
if ($needsUpdate) {
    $rows[] = [...];
} else {
    // 更新不要（updateTimeが同じ かつ 返信差分なし かつ その他の差分なし）
    $skippedCount++;
    $skippedReasons['no_changes']++;
}
```

### 3.2 needsUpdate の判定ロジック
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 477-488

```php
// 更新が必要な条件: updateTimeが新しい OR 返信が変わった OR 新規レコード
$needsUpdate = false;
if (!$existingReview) {
    // 新規レコード
    $needsUpdate = true;
} elseif ($updateTimeChanged || $replyChanged) {
    // 既存レコードで updateTimeが新しい OR 返信が変わった
    $needsUpdate = true;
    if ($replyChanged) {
        $replyDiffUpdateCount++;
    }
}
```

### 3.3 updateTimeChanged の判定ロジック
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 470-475

```php
// 更新判定: apiTime が存在し、既存より新しい場合
$updateTimeChanged = false;
if ($apiTime && $existingTime && $apiTime->greaterThan($existingTime)) {
    $updateTimeChanged = true;
    $updateCandidatesCount++;
}
```

### 3.4 shouldSkip と needsUpdate の関係
**ファイル**: `app/Services/ReviewSyncService.php`  
**行番号**: 490-540

```php
if ($shouldSkip && !$replyChanged) {
    // updateTime判定でスキップ かつ 返信差分なし
    $skippedCount++;
    $skippedReasons['update_time_lte_existing']++;
    continue;
}

// ... その他の変更チェック ...

// 変更がある場合のみ $rows に追加（needsUpdate判定を使用）
if ($needsUpdate) {
    $rows[] = [...];
} else {
    $skippedCount++;
    $skippedReasons['no_changes']++;
}
```

### 3.5 問題の可能性
**擬似コード**:
```
foreach (review as review) {
    existingReview = existingReviews.get(normalizeReviewId(reviewId))
    
    if (!existingReview) {
        needsUpdate = true  // 新規レコード
    } else {
        // 時刻比較
        if (apiTime > existingTime) {
            updateTimeChanged = true
        }
        shouldSkip = (apiTime <= existingTime)
        
        // 返信差分判定
        if (replyChanged) {
            needsUpdate = true
        }
        
        // 更新判定
        if (updateTimeChanged || replyChanged) {
            needsUpdate = true
        }
    }
    
    // スキップ判定
    if (shouldSkip && !replyChanged) {
        skip
        continue
    }
    
    // rows に追加
    if (needsUpdate) {
        rows[] = review
    }
}
```

**問題点**:
- `shouldSkip` と `needsUpdate` が独立している
- `shouldSkip=true` でも `replyChanged=true` なら `needsUpdate=true` になり、rows に追加される
- `shouldSkip=false` でも `updateTimeChanged=false` かつ `replyChanged=false` なら `needsUpdate=false` になり、スキップされる

**期待される動作**:
- `shouldSkip=true` かつ `replyChanged=false` → スキップ（rows に追加しない）
- `shouldSkip=false` または `replyChanged=true` → `needsUpdate` を判定して rows に追加

---

## 4. Photo の「増殖」原因を特定（調査のみ）

### 4.1 Photo同期の実装
**ファイル**: `app/Http/Controllers/ReviewsController.php`  
**行番号**: 563-580

```php
// スナップショット内でユニークにする（snapshot_id + gbp_media_id）
$photo = Photo::updateOrCreate(
    [
        'snapshot_id' => $snapshotId,
        'gbp_media_id' => $gbpMediaId,
    ],
    [
        'shop_id' => $shop->id,
        'gbp_media_name' => $gbpMediaName,
        // ... その他のフィールド
    ]
);

$wasRecentlyCreated = $photo->wasRecentlyCreated;

if ($wasRecentlyCreated) {
    $syncedCount++;
    Log::info('PHOTO_SYNC_CREATED', [...]);
}
```

### 4.2 photos テーブルの unique 制約
**ファイル**: `database/migrations/2026_01_31_000003_add_snapshot_id_to_photos_table.php`

```php
// マイグレーション履歴:
// 1. 初期: unique('gbp_media_id') のみ
// 2. snapshot_id追加後: unique(['snapshot_id', 'gbp_media_id'])
// 3. 現在: unique(['snapshot_id', 'gbp_media_id'])
```

**現在の unique 制約**: `['snapshot_id', 'gbp_media_id']`

### 4.3 増殖の原因候補

#### A. snapshot_id が毎回変わる
- **問題**: `snapshot_id` が毎回新しい値になると、同じ `gbp_media_id` でも別レコードとして扱われる
- **確認方法**: 同じ `gbp_media_id` で異なる `snapshot_id` のレコードが複数存在するか

#### B. gbp_media_id の抽出が不安定
- **問題**: `basename($gbpMediaName)` で抽出した `gbp_media_id` が毎回異なる可能性
- **確認方法**: 同じ写真で `gbp_media_id` が異なる値になっていないか

#### C. "profile" のような固定IDが毎回insertされる
- **問題**: プロフィール写真など、固定IDの写真が毎回新規insertされる
- **確認方法**: `gbp_media_id` が "profile" や固定値のレコードが複数存在するか

#### D. updateOrCreate の unique キーが正しく機能していない
- **問題**: `updateOrCreate` の第一引数（検索条件）が `['snapshot_id', 'gbp_media_id']` だが、DBの unique 制約と一致しているか
- **確認方法**: DBの unique 制約と `updateOrCreate` の検索条件が一致しているか

### 4.4 調査結果（コードから）

**現在の実装**:
- `updateOrCreate` の検索条件: `['snapshot_id', 'gbp_media_id']`
- DBの unique 制約: `['snapshot_id', 'gbp_media_id']` ✅ 一致している

**問題点**:
- `snapshot_id` が毎回変わるため、同じ `gbp_media_id` でも別レコードとして扱われる
- これは仕様通りかもしれないが、`shop_id` ベースの unique 制約がないため、同じ写真が複数のスナップショットで重複保存される

**推奨調査**:
1. 同じ `gbp_media_id` で異なる `snapshot_id` のレコードが複数存在するか確認
2. `shop_id` ベースの unique 制約が必要か検討

---

## 5. Post は仕様通り「毎回20件更新」でOK

### 5.1 Post同期の実装
**ファイル**: `app/Http/Controllers/ReportController.php`  
**行番号**: 1994-2015

```php
// upsertで保存（既存データも更新）
GbpPost::updateOrCreate(
    [
        'shop_id' => $shop->id,
        'gbp_post_id' => $gbpPostId,
    ],
    [
        'snapshot_id' => $snapshotId,
        'gbp_post_name' => $gbpPostName,
        // ... その他のフィールド
    ]
);
```

### 5.2 gbp_posts テーブルの unique 制約
**ファイル**: `database/migrations/2026_02_01_000003_remove_operator_id_from_gbp_posts_table.php`

```php
// マイグレーション履歴:
// 1. 初期: unique(['shop_id', 'operator_id', 'gbp_post_id'])
// 2. operator_id削除後: unique(['shop_id', 'gbp_post_id'])
```

**現在の unique 制約**: `['shop_id', 'gbp_post_id']` ✅

### 5.3 調査結果
- `updateOrCreate` の検索条件: `['shop_id', 'gbp_post_id']` ✅
- DBの unique 制約: `['shop_id', 'gbp_post_id']` ✅ 一致している
- 毎回 insert になっていないか: `updateOrCreate` を使用しているため、既存レコードは更新される ✅

**結論**: Post同期は仕様通り「毎回20件更新」で問題なし。

---

## 6. 調査ログの確認方法

### 6.1 ログキー
1. `REVIEWS_LOOKUP_DEBUG` - 既存レビュー lookup の結果（最初の5件）
2. `REVIEWS_TIME_COMPARISON_DEBUG` - 時刻比較の詳細（最初の5件）
3. `REVIEWS_ID_MISMATCH` - キー不一致の詳細（最初の5件）
4. `ReviewSyncService: 口コミ同期完了` - 最終的な統計情報

### 6.2 確認コマンド
```bash
# 既存レビュー lookup の結果
grep "REVIEWS_LOOKUP_DEBUG" storage/logs/laravel.log | tail -20

# 時刻比較の詳細
grep "REVIEWS_TIME_COMPARISON_DEBUG" storage/logs/laravel.log | tail -20

# 最終的な統計情報
grep "ReviewSyncService: 口コミ同期完了" storage/logs/laravel.log | tail -10
```

### 6.3 確認ポイント
1. `existing_review_hit` が `HIT` か `MISS` か（5件中何件がHITか）
2. `api_rounded` と `existing_rounded` が同じなのに `should_skip=false` になっていないか
3. `existing_raw_source` が `gbp_update_time` になっているか
4. `will_add_to_rows` が `true` になる条件

---

## 7. 原因特定のためのチェックリスト

### 7.1 キー不一致の可能性
- [ ] `REVIEWS_LOOKUP_DEBUG` で `existing_review_hit=MISS` が5件中5件
- [ ] `api_review_id_normalized` と `existing_reviews_keys_sample` が一致していない
- [ ] `db_gbp_review_ids_normalized_sample` と `api_review_id_normalized` が一致していない

**判定**: 常に `MISS` なら → キー不一致が原因

### 7.2 時刻比較の問題
- [ ] `api_rounded` と `existing_rounded` が同じなのに `should_skip=false`
- [ ] `existing_raw_source` が `update_time` や `create_time` になっている（`gbp_update_time` が NULL）
- [ ] `existing_raw` が Carbon で再parseしている（タイムゾーン9時間ズレ）

**判定**: 時刻が同じなのに `should_skip=false` なら → 時刻比較ロジックの問題

### 7.3 needsUpdate 判定の問題
- [ ] `should_skip=false` でも `updateTimeChanged=false` かつ `replyChanged=false` なのに `needsUpdate=true`
- [ ] `should_skip=true` でも `replyChanged=true` で `needsUpdate=true` になり、rows に追加される

**判定**: `needsUpdate` の判定ロジックに問題がある可能性

---

## 8. 次のステップ

1. **ログを確認**: 上記のログキーで実際の値を確認
2. **原因を特定**: チェックリストに基づいて原因を1つに絞り込む
3. **修正案の提示**: 原因が特定できたら修正案を提示（今回は調査のみ）

---

## 9. 調査結果サマリー（コードから推測）

### 9.1 Review同期
- **既存レビュー lookup**: `normalizeReviewId` で正規化したキーで検索 ✅
- **時刻比較**: 分単位に丸めた値で比較（`gbp_update_time` の生の値は比較に使われていない）⚠️
- **rows への追加条件**: `needsUpdate` が `true` の場合のみ ✅
- **問題の可能性**: `existingReview` が常に `null` になっている、または時刻比較が常に `updateTimeChanged=true` になっている

### 9.2 Photo同期
- **unique 制約**: `['snapshot_id', 'gbp_media_id']` ✅
- **updateOrCreate の検索条件**: `['snapshot_id', 'gbp_media_id']` ✅
- **問題の可能性**: `snapshot_id` が毎回変わるため、同じ `gbp_media_id` でも別レコードとして扱われる（仕様通りかもしれない）

### 9.3 Post同期
- **unique 制約**: `['shop_id', 'gbp_post_id']` ✅
- **updateOrCreate の検索条件**: `['shop_id', 'gbp_post_id']` ✅
- **問題なし**: 仕様通り「毎回20件更新」で問題なし ✅

---

## 10. 追加したログの詳細

### 10.1 REVIEWS_LOOKUP_DEBUG
- **出力タイミング**: 各レビューの処理開始時（最初の5件のみ）
- **内容**: 
  - `api_review_id_raw`: APIから取得した生のreviewId
  - `api_review_id_normalized`: 正規化後のreviewId
  - `existing_reviews_keys_sample`: 既存レビューのキーサンプル（正規化済み）
  - `existing_review_hit`: HIT または MISS
  - `db_gbp_review_ids_sample`: DBのgbp_review_idの実値（先頭5件）
  - `db_gbp_review_ids_normalized_sample`: DBのgbp_review_idを正規化した値

### 10.2 REVIEWS_TIME_COMPARISON_DEBUG
- **出力タイミング**: 時刻比較判定後（最初の5件のみ）
- **内容**:
  - `api_raw`: APIから取得した生のupdateTime/createTime
  - `api_parsed_utc`: パース後のUTC時刻（丸め前）
  - `api_rounded`: 分単位に丸めた値
  - `existing_raw`: 既存時刻の生の値（型情報付き）
  - `existing_raw_value`: 既存時刻の生の値（文字列）
  - `existing_raw_source`: どのカラムから取得したか（gbp_update_time / update_time / create_time）
  - `existing_parsed_utc`: パース後のUTC時刻（丸め前）
  - `existing_rounded`: 分単位に丸めた値
  - `update_time_changed`: updateTimeが変更されたか
  - `should_skip`: スキップ判定の結果
  - `reply_changed`: 返信が変更されたか
  - `needs_update`: 更新が必要か
  - `will_add_to_rows`: rows に追加されるか

---

## 11. 修正した既存時刻のパース処理

### 11.1 変更内容
**変更前**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    $existingTimeRaw = $existingRaw->format('Y-m-d H:i:s');
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
}
```

**変更後**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    // Carbon型の場合は ->utc() で直接UTCに変換（再parseしない）
    $existingTime = CarbonImmutable::instance($existingRaw)->utc();
}
```

### 11.2 理由
- 再parseするとタイムゾーンが9時間ズレる可能性がある
- Carbon インスタンスの場合は直接 `->utc()` で変換する方が安全

---

## 12. 調査完了後の確認事項

1. **ログを確認**: `REVIEWS_LOOKUP_DEBUG` と `REVIEWS_TIME_COMPARISON_DEBUG` のログを確認
2. **原因を特定**: チェックリストに基づいて原因を1つに絞り込む
3. **修正案の提示**: 原因が特定できたら修正案を提示（今回は調査のみ）

---

## 13. コード引用（rows に追加される条件）

### 13.1 needsUpdate の判定
```php
// 更新が必要な条件: updateTimeが新しい OR 返信が変わった OR 新規レコード
$needsUpdate = false;
if (!$existingReview) {
    // 新規レコード
    $needsUpdate = true;
} elseif ($updateTimeChanged || $replyChanged) {
    // 既存レコードで updateTimeが新しい OR 返信が変わった
    $needsUpdate = true;
    if ($replyChanged) {
        $replyDiffUpdateCount++;
    }
}
```

### 13.2 rows への追加
```php
// 変更がある場合のみ $rows に追加（needsUpdate判定を使用）
if ($needsUpdate) {
    $rows[] = [...];
} else {
    // 更新不要（updateTimeが同じ かつ 返信差分なし かつ その他の差分なし）
    $skippedCount++;
    $skippedReasons['no_changes']++;
}
```

**結論**: `needsUpdate` が `true` の場合のみ rows に追加される。`needsUpdate` が常に `true` になる原因を特定する必要がある。








