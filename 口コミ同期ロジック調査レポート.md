# MEO 口コミ同期ロジック調査レポート

## 調査目的
「差分判定が正しく gbp_update_time ベースで行われているか」を確認する。

## 調査対象ファイル
- `app/Services/ReviewSyncService.php`
- `app/Services/GoogleBusinessProfileService.php`
- `app/Http/Controllers/ReviewsController.php`

---

## 1. APIから取得している時刻フィールド

### 1.1 取得元
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 263-265

```php
$apiUpdateTimeRaw = data_get($review, 'updateTime');
$apiCreateTimeRaw = data_get($review, 'createTime');
$apiRaw = $apiUpdateTimeRaw ?? $apiCreateTimeRaw ?? null;
```

### 1.2 使用フィールド
- **`review['updateTime']`**: 優先的に使用
- **`review['createTime']`**: `updateTime` が存在しない場合のフォールバック
- **`api_update_time` として扱う値**: `$apiRaw` = `updateTime ?? createTime`

### 1.3 Carbon parse の箇所
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 273, 277

```php
// 比較用（分単位に丸める）
$apiTime = CarbonImmutable::parse($apiRaw, 'UTC')->utc();
$apiTime = $this->roundToMinute($apiTime);

// DB保存用（丸めない生の値）
$gbpUpdateTime = CarbonImmutable::parse($apiRaw, 'UTC')->utc();
```

**parse のタイミング**: APIから取得した直後、比較とDB保存の両方で使用

---

## 2. DB保存時に使っているカラム

### 2.1 保存されるカラムと値
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 730-744

```php
$rows[] = [
    'update_time' => $apiTime ? $apiTime->format('Y-m-d H:i:s') : $createTime->format('Y-m-d H:i:s'),
    // ↑ 分単位に丸めた値（秒以下は00）
    
    'gbp_update_time' => $gbpUpdateTime ? $gbpUpdateTime->format('Y-m-d H:i:s') : null,
    // ↑ Google側のupdateTime（分単位に丸めない生の値）
    
    'gbp_create_time' => $gbpCreateTime ? $gbpCreateTime->format('Y-m-d H:i:s') : null,
    // ↑ Google側のcreateTime
    
    'create_time' => $createTime->format('Y-m-d H:i:s'),
    // ↑ createTime（分単位に丸めない）
];
```

### 2.2 各カラムの役割
| カラム名 | 保存される値 | 用途 |
|---------|------------|------|
| `update_time` | `apiTime`（分単位に丸めた値）または `createTime` | 後方互換用、比較用（分単位） |
| `gbp_update_time` | `gbpUpdateTime`（丸めない生の値） | **差分同期のキー**、Google側の正確なupdateTime |
| `gbp_create_time` | `gbpCreateTime`（丸めない生の値） | Google側のcreateTime |
| `create_time` | `createTime`（丸めない生の値） | 後方互換用 |

---

## 3. 差分判定の実装箇所

### 3.1 既存レコード取得
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 206-212

```php
$existingReviews = Review::where('shop_id', $shop->id)
    ->whereNotNull('gbp_review_id')
    ->get()
    ->keyBy(function ($review) {
        return $this->normalizeReviewId((string)$review->gbp_review_id);
    });
```

**取得条件**: `shop_id` と `gbp_review_id` が NOT NULL のレコードを全件取得

### 3.2 既存時刻の取得（差分判定用）
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 379-383

```php
$existingRaw = $existingReview->gbp_update_time 
    ?? $existingReview->update_time 
    ?? $existingReview->create_time 
    ?? null;
```

**優先順位**:
1. `gbp_update_time`（最優先）✅
2. `update_time`（フォールバック）
3. `create_time`（フォールバック）

### 3.3 比較に使っているカラム
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 423-424

```php
if ($existingTime && $apiTime) {
    $shouldSkip = $apiTime->lessThanOrEqualTo($existingTime);
}
```

**比較対象**:
- **API側**: `$apiTime`（`updateTime ?? createTime` を分単位に丸めた値）
- **既存側**: `$existingTime`（`gbp_update_time ?? update_time ?? create_time` を分単位に丸めた値）

**問題点**: 
- 既存側は `gbp_update_time` を優先しているが、比較時は分単位に丸めた値を使用
- API側も分単位に丸めた値を使用しているため、`gbp_update_time` の生の値は比較に使われていない

### 3.4 差分判定のロジック
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 423-428, 490-540

```php
// 判定: api_min > existing_min なら更新、それ以外は更新不要
if ($existingTime && $apiTime) {
    $shouldSkip = $apiTime->lessThanOrEqualTo($existingTime);
} elseif (!$apiTime) {
    $shouldSkip = true; // apiTimeがnullの場合はスキップ
}

// スキップ判定
if ($shouldSkip && !$replyChanged) {
    // updateTime判定でスキップ かつ 返信差分なし
    $skippedCount++;
    continue;
}
```

**判定ロジック**:
- `apiTime <= existingTime` ならスキップ（更新不要）
- `apiTime > existingTime` なら更新対象
- `apiTime` が null の場合はスキップ（返信差分判定は別で走る）

---

## 4. reply差分判定

### 4.1 reviewReply キーの存在確認
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 433

```php
$hasReplyKey = array_key_exists('reviewReply', $review);
```

**使用関数**: `array_key_exists()` ✅（`isset()` は使用していない）

### 4.2 フィールド不在と null の区別
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 438-467, 704-722

```php
if ($hasReplyKey) {
    // 返信フィールドが存在する時だけ比較
    $apiReplyText = $review['reviewReply']['comment'] ?? null;
    // ... 比較処理
} 
// if !hasReplyKey: 返信差分判定は "しない"（不明扱い）。DB側をnullに上書きもしない。

// DB保存時
if ($hasReplyKey) {
    $replyTextToSave = $apiReplyText;
} elseif ($existingReview) {
    // キー不在 かつ 既存レコードがある場合: DB側をnullに上書きしない（既存値を保持）
    $replyTextToSave = $existingReview->reply_text;
}
```

**区別の実装**: ✅ 正しく実装されている
- `array_key_exists('reviewReply', $review)` でキーの存在を確認
- キー不在の場合はDB側をnullに上書きしない（既存値を保持）

### 4.3 reply差分と updateTime の連動
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 477-488, 490-540

```php
// 更新が必要な条件: updateTimeが新しい OR 返信が変わった OR 新規レコード
$needsUpdate = false;
if (!$existingReview) {
    $needsUpdate = true; // 新規レコード
} elseif ($updateTimeChanged || $replyChanged) {
    $needsUpdate = true; // 既存レコードで updateTimeが新しい OR 返信が変わった
}

if ($shouldSkip && !$replyChanged) {
    // updateTime判定でスキップ かつ 返信差分なし → スキップ
    continue;
}
```

**連動の有無**: ❌ **独立している**（正しい実装）
- `updateTime` が同じでも `replyChanged` が true なら UPDATE
- `updateTime` が新しい場合も UPDATE
- 両方が false の場合のみスキップ

---

## 5. 分単位丸めの実装箇所

### 5.1 丸め関数
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 33-36

```php
private function roundToMinute(CarbonImmutable $time): CarbonImmutable
{
    return $time->copy()->startOfMinute();
}
```

**使用メソッド**: `startOfMinute()` ✅

### 5.2 丸めの適用箇所

#### API側
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 273-275

```php
$apiTime = CarbonImmutable::parse($apiRaw, 'UTC')->utc();
$apiTime = $this->roundToMinute($apiTime); // 分単位に丸める
```

#### 既存側（DB）
- **ファイル**: `app/Services/ReviewSyncService.php`
- **行番号**: 397-398

```php
$existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
$existingTime = $this->roundToMinute($existingTime); // 分単位に丸める
```

### 5.3 丸めのタイミング
- **API側**: parse 直後、比較前に丸める
- **DB側**: parse 直後、比較前に丸める
- **比較**: 両方とも丸めた値で比較

**注意**: `gbp_update_time` は丸めずにDBに保存されるが、比較には使われていない（丸めた `$apiTime` と `$existingTime` で比較）

---

## 6. 現在の判定ロジック（擬似コード）

```
// STEP0: 事前準備
cutoff = shop.last_reviews_synced_update_time (NULLなら初回フル同期)
maxSeen = cutoff

// STEP1: ページ取得ループ
do {
    ページ取得
    foreach (reviewsThisPage as review) {
        reviewUpdate = parse(review.updateTime ?? review.createTime)
        if (cutoff != NULL && reviewUpdate <= cutoff) {
            早期停止（break 2）
        }
        allReviews[] = review
    }
} while (nextPageToken != null)

// STEP2: 既存レビュー取得
existingReviews = Review.where('shop_id', shop.id)
    .whereNotNull('gbp_review_id')
    .get()
    .keyBy('normalizeReviewId(gbp_review_id)')

// STEP3: 各レビューの差分判定
foreach (allReviews as review) {
    // API時刻取得
    apiRaw = review.updateTime ?? review.createTime
    apiTime = parse(apiRaw, UTC) -> roundToMinute()  // 分単位に丸める
    gbpUpdateTime = parse(apiRaw, UTC)  // 丸めない（DB保存用）
    
    // 既存レビュー取得
    existingReview = existingReviews.get(normalizeReviewId(reviewId))
    
    if (existingReview) {
        // 既存時刻取得（優先順位: gbp_update_time > update_time > create_time）
        existingRaw = existingReview.gbp_update_time 
            ?? existingReview.update_time 
            ?? existingReview.create_time
        existingTime = parse(existingRaw, UTC) -> roundToMinute()  // 分単位に丸める
        
        // 時刻比較
        if (apiTime && existingTime) {
            shouldSkip = (apiTime <= existingTime)
        } else {
            shouldSkip = true  // apiTimeがnullならスキップ
        }
    }
    
    // 返信差分判定（updateTimeと独立）
    hasReplyKey = array_key_exists('reviewReply', review)
    if (hasReplyKey) {
        apiReplyText = review.reviewReply.comment ?? null
        if (existingReview) {
            replyChanged = (apiReplyText !== existingReview.reply_text)
        } else {
            replyChanged = (apiReplyText !== null)
        }
    }
    
    // 更新判定
    updateTimeChanged = (apiTime > existingTime)
    needsUpdate = false
    if (!existingReview) {
        needsUpdate = true  // 新規レコード
    } else if (updateTimeChanged || replyChanged) {
        needsUpdate = true  // updateTimeが新しい OR 返信が変わった
    }
    
    // スキップ判定
    if (shouldSkip && !replyChanged) {
        skip  // updateTime判定でスキップ かつ 返信差分なし
        continue
    }
    
    // DB保存
    if (needsUpdate) {
        rows[] = {
            update_time: apiTime (分単位に丸めた値),
            gbp_update_time: gbpUpdateTime (丸めない生の値),
            gbp_create_time: gbpCreateTime,
            reply_text: (hasReplyKey ? apiReplyText : existingReview.reply_text),
            has_reply: (hasReplyKey && apiReplyText !== null)
        }
    }
}

// STEP4: maxSeen更新
foreach (rows as row) {
    if (gbpUpdateTime > maxSeen) {
        maxSeen = gbpUpdateTime
    }
}

// STEP5: DB upsert
Review.upsert(rows, ['shop_id', 'gbp_review_id'], updateColumns)

// STEP6: cutoff更新
if (maxSeen != NULL) {
    shop.last_reviews_synced_update_time = maxSeen
}
```

---

## 7. 問題点の指摘

### 7.1 gbp_update_time ベースの差分判定が不完全

**現状**:
- 既存側の取得では `gbp_update_time` を優先している（行379-383）✅
- しかし、比較時は分単位に丸めた値を使用している（行397-398, 423-424）❌

**問題**:
- `gbp_update_time` は丸めずにDBに保存されるが、比較には使われていない
- 比較には `$apiTime`（丸めた値）と `$existingTime`（丸めた値）を使用
- つまり、`gbp_update_time` の生の値は比較に使われていない

**影響**:
- 秒単位の差がある場合、分単位に丸めることで同じ値になり、正しく差分判定できない可能性がある
- ただし、現状の実装では「分単位の差」で判定しているため、秒単位の差は無視される設計になっている

### 7.2 cutoff判定と差分判定の不整合

**cutoff判定**（行138-154）:
- `reviewUpdate`（丸めない生の値）と `cutoff`（丸めない生の値）を比較
- `reviewUpdate <= cutoff` で早期停止

**差分判定**（行423-424）:
- `apiTime`（丸めた値）と `existingTime`（丸めた値）を比較
- `apiTime <= existingTime` でスキップ

**問題**:
- cutoff判定は生の値で比較しているが、差分判定は丸めた値で比較している
- この不整合により、cutoff判定で通過したレビューが差分判定でスキップされる可能性がある

---

## 8. まとめ

### 8.1 現在の実装状況

| 項目 | 実装状況 | 備考 |
|------|---------|------|
| API時刻取得 | ✅ `updateTime` 優先、`createTime` フォールバック | |
| DB保存 | ✅ `gbp_update_time` に生の値を保存 | |
| 既存時刻取得 | ✅ `gbp_update_time` を優先 | |
| 差分判定 | ⚠️ 丸めた値で比較（`gbp_update_time` の生の値は未使用） | |
| 返信差分判定 | ✅ `array_key_exists` でキー存在確認、独立判定 | |
| 分単位丸め | ✅ `startOfMinute()` を使用、比較前に適用 | |

### 8.2 結論

**差分判定は `gbp_update_time` ベースで行われているが、比較時は分単位に丸めた値を使用している。**

- ✅ 既存側の取得では `gbp_update_time` を優先
- ✅ `gbp_update_time` は丸めずにDBに保存
- ❌ 比較時は分単位に丸めた値を使用（`gbp_update_time` の生の値は比較に使われていない）

**推奨**:
- 比較時も `gbp_update_time` の生の値を使用するか、または分単位丸めの設計意図を明確にする必要がある








