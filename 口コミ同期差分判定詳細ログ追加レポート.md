# 口コミ同期差分判定詳細ログ追加レポート

## 修正内容

### 目的
差分判定が全件UPSERTになる原因を確定するため、shopごとに先頭3件だけ詳細なログを出力する。

### 実装箇所
**対象ファイル**: `app/Services/ReviewSyncService.php`**

**修正箇所**: 
- `shouldSkip` 判定後のログ出力（201-211行目 → 削除）
- `hasChanges` 判定時のログ出力（新規追加）

### ログ項目（必須）

#### REVIEWS_DIFF_DECISION ログ

**出力タイミング**:
- `shouldSkip = true` の場合（SKIP時）
- `hasChanges` 判定後（UPSERT/SKIP時）
- 新規レコードの場合（UPSERT時）

**ログ項目**:
- `shop_id`: 店舗ID
- `gbp_review_id`: レビューID
- `api_update_time`: APIから取得したupdate_time（フォールバック後の最終値、`Y-m-d H:i:s`形式）
- `existing_update_time`: 既存レコードのupdate_time（nullならcreate_time、`Y-m-d H:i:s`形式）
- `compare_api_lte_existing`: APIのupdate_time <= 既存のupdate_time かどうか（true/false）
- `api_replied_at`: APIから取得したreplied_at（`Y-m-d H:i:s`形式、null可）
- `existing_replied_at`: 既存レコードのreplied_at（`Y-m-d H:i:s`形式、null可）
- `api_reply_text_hash`: APIから取得したreply_textのSHA1ハッシュ（null可）
- `existing_reply_text_hash`: 既存レコードのreply_textのSHA1ハッシュ（null可）
- `api_comment_hash`: APIから取得したcommentのSHA1ハッシュ（null可）
- `existing_comment_hash`: 既存レコードのcommentのSHA1ハッシュ（null可）
- `decision`: 判定結果（`SKIP` または `UPSERT`）
- `reason`: 判定理由（例: `update_time_lte_existing`, `update_time_gt`, `reply_text_diff`, `comment_diff`, `replied_at_diff`, `new_record`, `no_changes`）

**出力件数**: 1店舗あたり最大3件（`count($rows) < 3` または `$skippedCount <= 3`）

### 判定理由（reason）の種類

1. **`update_time_lte_existing`**: APIのupdate_time <= 既存のupdate_time のためSKIP
2. **`update_time_gt`**: APIのupdate_time > 既存のupdate_time のためUPSERT
3. **`reply_text_diff`**: 返信テキストが異なるためUPSERT
4. **`comment_diff`**: コメントが異なるためUPSERT
5. **`replied_at_diff`**: 返信日時が異なるためUPSERT
6. **`author_name_diff`**: 投稿者名が異なるためUPSERT
7. **`rating_diff`**: 評価が異なるためUPSERT
8. **`new_record`**: 新規レコードのためUPSERT
9. **`no_changes`**: 変更がないためSKIP

### 実装詳細

#### SKIP時のログ（`shouldSkip = true`）

```php
if ($shouldSkip) {
    $skippedCount++;
    // 検証用ログ（最初の3件のみ）
    if ($skippedCount <= 3) {
        $existingUpdateTime = $existingReview && $existingTime 
            ? $existingTime->format('Y-m-d H:i:s')
            : ($existingReview && $existingReview->create_time 
                ? ($existingReview->create_time instanceof \Carbon\Carbon 
                    ? $existingReview->create_time->format('Y-m-d H:i:s')
                    : (string)$existingReview->create_time)
                : null);
        
        Log::info('REVIEWS_DIFF_DECISION', [
            'shop_id' => $shop->id,
            'gbp_review_id' => $reviewId,
            'api_update_time' => $effectiveUpdateTime->format('Y-m-d H:i:s'),
            'existing_update_time' => $existingUpdateTime,
            'compare_api_lte_existing' => $existingTime ? $effectiveUpdateTime->lte($existingTime) : false,
            'api_replied_at' => null, // SKIP時は未取得
            'existing_replied_at' => $existingReview && $existingReview->replied_at 
                ? ($existingReview->replied_at instanceof \Carbon\Carbon 
                    ? $existingReview->replied_at->format('Y-m-d H:i:s')
                    : (string)$existingReview->replied_at)
                : null,
            'api_reply_text_hash' => null,
            'existing_reply_text_hash' => $existingReview && $existingReview->reply_text 
                ? sha1($existingReview->reply_text) 
                : null,
            'api_comment_hash' => null,
            'existing_comment_hash' => $existingReview && $existingReview->comment 
                ? sha1($existingReview->comment) 
                : null,
            'decision' => 'SKIP',
            'reason' => 'update_time_lte_existing',
        ]);
    }
    continue;
}
```

#### UPSERT/SKIP判定時のログ（`hasChanges` 判定後）

```php
// 変更があるかチェック（理由を記録）
$changeReasons = [];

if ($newAuthorName !== $existingAuthorName) {
    $hasChanges = true;
    $changeReasons[] = 'author_name_diff';
}
if ($newRating !== $existingRating) {
    $hasChanges = true;
    $changeReasons[] = 'rating_diff';
}
if ($newComment !== $existingComment) {
    $hasChanges = true;
    $changeReasons[] = 'comment_diff';
}
if ($newReplyText !== $existingReplyText) {
    $hasChanges = true;
    $changeReasons[] = 'reply_text_diff';
}
if ($newRepliedAt !== $existingRepliedAt) {
    $hasChanges = true;
    $changeReasons[] = 'replied_at_diff';
}
if ($existingTime && $effectiveUpdateTime->gt($existingTime)) {
    $hasChanges = true;
    $changeReasons[] = 'update_time_gt';
}

// 検証用ログ（最初の3件のみ）
if (count($rows) < 3) {
    Log::info('REVIEWS_DIFF_DECISION', [
        'shop_id' => $shop->id,
        'gbp_review_id' => $reviewId,
        'api_update_time' => $effectiveUpdateTime->format('Y-m-d H:i:s'),
        'existing_update_time' => $existingUpdateTime,
        'compare_api_lte_existing' => $existingTime ? $effectiveUpdateTime->lte($existingTime) : false,
        'api_replied_at' => $newRepliedAt,
        'existing_replied_at' => $existingRepliedAt,
        'api_reply_text_hash' => $newReplyText ? sha1($newReplyText) : null,
        'existing_reply_text_hash' => $existingReplyText ? sha1($existingReplyText) : null,
        'api_comment_hash' => $newComment ? sha1($newComment) : null,
        'existing_comment_hash' => $existingComment ? sha1($existingComment) : null,
        'decision' => $hasChanges ? 'UPSERT' : 'SKIP',
        'reason' => $hasChanges ? implode(',', $changeReasons) : 'no_changes',
    ]);
}
```

#### 新規レコード時のログ

```php
// 新規レコード
$hasChanges = true;

// 検証用ログ（最初の3件のみ）
if (count($rows) < 3) {
    Log::info('REVIEWS_DIFF_DECISION', [
        'shop_id' => $shop->id,
        'gbp_review_id' => $reviewId,
        'api_update_time' => $effectiveUpdateTime->format('Y-m-d H:i:s'),
        'existing_update_time' => null,
        'compare_api_lte_existing' => false,
        'api_replied_at' => data_get($review, 'reviewReply.updateTime') 
            ? Carbon::parse(data_get($review, 'reviewReply.updateTime'))->utc()->format('Y-m-d H:i:s')
            : null,
        'existing_replied_at' => null,
        'api_reply_text_hash' => data_get($review, 'reviewReply.comment') ? sha1(data_get($review, 'reviewReply.comment')) : null,
        'existing_reply_text_hash' => null,
        'api_comment_hash' => isset($review['comment']) ? sha1($review['comment']) : null,
        'existing_comment_hash' => null,
        'decision' => 'UPSERT',
        'reason' => 'new_record',
    ]);
}
```

## 検証手順

### 1. 同期を実行

Web UIから同期ボタンを押す、または tinker で実行

### 2. ログを確認

```bash
# REVIEWS_DIFF_DECISION ログを抽出
grep "REVIEWS_DIFF_DECISION" storage/logs/laravel.log | tail -20

# 特定のshop_idで確認
grep "REVIEWS_DIFF_DECISION" storage/logs/laravel.log | grep '"shop_id":1' | tail -3

# JSON形式で整形して確認（jqがある場合）
grep "REVIEWS_DIFF_DECISION" storage/logs/laravel.log | tail -3 | jq .
```

### 3. ログから原因を特定

**確認ポイント**:
1. **`decision` が `UPSERT` の場合**:
   - `reason` を確認して、どの項目が変更と判定されているか確認
   - `compare_api_lte_existing` が `false` の場合、`update_time_gt` が原因の可能性
   - `api_reply_text_hash` と `existing_reply_text_hash` が異なる場合、`reply_text_diff` が原因
   - `api_comment_hash` と `existing_comment_hash` が異なる場合、`comment_diff` が原因

2. **`decision` が `SKIP` の場合**:
   - `reason` が `update_time_lte_existing` または `no_changes` であることを確認
   - `compare_api_lte_existing` が `true` であることを確認

3. **全件UPSERTになる原因の特定**:
   - すべてのログで `decision` が `UPSERT` の場合、`reason` を確認
   - `reason` が `update_time_gt` の場合、タイムゾーンや時刻比較の問題の可能性
   - `reason` が `comment_diff` や `reply_text_diff` の場合、正規化（trim等）の問題の可能性

## 期待される結果

### 正常な場合（差分同期が効いている）

1回目の同期:
- `decision`: `UPSERT`（新規または変更あり）
- `reason`: `new_record` または `update_time_gt`, `comment_diff` など

2回目の同期（変更がない場合）:
- `decision`: `SKIP`
- `reason`: `update_time_lte_existing` または `no_changes`
- `compare_api_lte_existing`: `true`

### 問題がある場合（全件UPSERTになる）

2回目の同期でも:
- `decision`: `UPSERT`
- `reason`: `update_time_gt` など（毎回変わる値が原因）
- `compare_api_lte_existing`: `false`（時刻比較の問題）

## 完了条件

✅ 差分判定の詳細ログを追加（`REVIEWS_DIFF_DECISION`）  
✅ 1店舗あたり最大3件だけログを出力  
✅ ログ項目をすべて実装（shop_id, gbp_review_id, api_update_time, existing_update_time, compare_api_lte_existing, api_replied_at, existing_replied_at, api_reply_text_hash, existing_reply_text_hash, api_comment_hash, existing_comment_hash, decision, reason）  
✅ 文字列はSHA1ハッシュで出力（改行/空白差分の検知用）  
✅ 判定理由（reason）を詳細に記録  

**検証**: 上記の検証手順に従って、ログを確認し、全件UPSERTになる原因を特定








