# アカウント別同期の分析レポート

## ① 同期データの保存構造

### テーブル構造

#### `gbp_snapshots` テーブル
```sql
- id (PK)
- shop_id (FK)
- synced_by_operator_id (nullable, FK to operation_persons) -- ログ用のみ
- synced_at (timestamp)
- photos_count (integer)
- reviews_count (integer)
- posts_count (integer)
- sync_params (JSON) -- { "start_date": "2026-01-01", "end_date": "2026-01-31" }
- created_at, updated_at
```

**重要な事実:**
- `synced_by_operator_id` は **ログ用のみ**（nullable）
- 同期期間は `sync_params` JSON に保存される
- **アカウントID（user_id）は保存されていない**
- インデックス: `['shop_id', 'synced_at']` （operator_id は含まれていない）

#### `reviews` テーブル
```sql
- id (PK)
- shop_id (FK)
- snapshot_id (FK to gbp_snapshots)
- gbp_review_id (string)
- author_name, rating, comment, create_time, reply_text, replied_at
- created_at, updated_at
```

**ユニーク制約:** `['snapshot_id', 'gbp_review_id']`

**重要な事実:**
- `operator_id` カラムは **存在しない**（マイグレーション `2026_02_01_000010_ensure_no_operator_id_in_reviews_photos_posts.php` で削除済み）
- 保存キー: `snapshot_id + gbp_review_id` の組み合わせ
- **アカウント識別子は含まれていない**

#### `photos` テーブル
```sql
- id (PK)
- shop_id (FK)
- snapshot_id (FK to gbp_snapshots)
- gbp_media_id (string)
- gbp_media_name, media_format, google_url, thumbnail_url, create_time, ...
- created_at, updated_at
```

**ユニーク制約:** `['snapshot_id', 'gbp_media_id']`

**重要な事実:**
- `operator_id` カラムは **存在しない**
- 保存キー: `snapshot_id + gbp_media_id` の組み合わせ
- **アカウント識別子は含まれていない**

### 結論（①）
- **同期データは「どのキー」で保存されているか:**
  - `reviews`: `['snapshot_id', 'gbp_review_id']`
  - `photos`: `['snapshot_id', 'gbp_media_id']`
  - **アカウントID（user_id, operator_id）は保存キーに含まれていない**

- **期間はテーブルに保存されているか:**
  - ✅ `gbp_snapshots.sync_params` (JSON) に保存されている

- **アカウントID（ユーザー単位 or 管理者単位）はどこに保存されているか:**
  - ❌ **保存されていない**（`synced_by_operator_id` はログ用のみで、データ分離には使われていない）

---

## ② 同期処理の実装

### 同期開始時のパラメータ

**実コード確認箇所:**
- `app/Http/Controllers/ReportController.php::sync()` (line 369-695)
- `app/Http/Controllers/ShopController.php::scheduleSync()` (line 631-842)
- `app/Http/Controllers/ReviewsController.php::sync()` (line 230-395)

**同期開始時の処理:**
```php
// 1. スナップショットを作成
$snapshot = GbpSnapshot::create([
    'shop_id' => $shop->id,
    'synced_by_operator_id' => $operatorId, // nullable, ログ用のみ
    'synced_at' => now(),
    'sync_params' => [
        'start_date' => $startDateCarbon?->format('Y-m-d'),
        'end_date' => $endDateCarbon?->format('Y-m-d'),
    ],
]);

// 2. 口コミを同期
Review::updateOrCreate(
    [
        'snapshot_id' => $snapshotId,
        'gbp_review_id' => $gbpReviewIdClean,
    ],
    [
        'shop_id' => $shop->id,
        // ... その他のフィールド
    ]
);

// 3. 写真を同期
Photo::updateOrCreate(
    [
        'snapshot_id' => $snapshotId,
        'gbp_media_id' => $gbpMediaId,
    ],
    [
        'shop_id' => $shop->id,
        // ... その他のフィールド
    ]
);
```

### 質問への回答（②）

- **保存時のキーに user_id / operator_id / account_id は含まれているか:**
  - ❌ **含まれていない**
  - `reviews`: `['snapshot_id', 'gbp_review_id']` のみ
  - `photos`: `['snapshot_id', 'gbp_media_id']` のみ

- **それとも「店舗IDだけ」などで上書きされているか:**
  - ❌ 店舗IDだけではない
  - **`snapshot_id` ごとに分離されている**
  - ただし、**アカウント単位での分離はされていない**

- **同期期間は where 条件に使われているか:**
  - ✅ 同期処理内で `create_time` でフィルタリングされている（line 753-767, 921-937）
  - ただし、**保存時には期間情報は reviews/photos テーブルに保存されない**
  - 期間情報は `gbp_snapshots.sync_params` にのみ保存される

---

## ③ 表示側（管理者画面）のデータ取得条件

### スケジュール画面 (`ShopController::schedule`)

```php
// 最新のスナップショットを取得（GBPデータは共有なので、最新のものを取得）
$latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
    ->orderBy('synced_at', 'desc')
    ->first();

$snapshotId = $latestSnapshot?->id;

// 指定された年月の口コミを取得（最新スナップショットのもの）
$reviewsQuery = Review::where('shop_id', $shop->id)
    ->whereBetween('create_time', [$startDate, $endDate]);
if ($snapshotId) {
    $reviewsQuery->where('snapshot_id', $snapshotId);
}
```

**SQL相当:**
```sql
SELECT * FROM gbp_snapshots 
WHERE shop_id = ? 
ORDER BY synced_at DESC 
LIMIT 1;

SELECT * FROM reviews 
WHERE shop_id = ? 
  AND snapshot_id = ? 
  AND create_time BETWEEN ? AND ?;
```

### レポート画面 (`ReportController::show`)

```php
// 最新のスナップショットを取得（GBPデータは共有なので、operator_idは関係ない）
$latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
    ->orderBy('synced_at', 'desc')
    ->first();

// 口コミ数：該当期間で投稿された口コミ数（ユニーク）
$currentReviewIds = DB::table('reviews')
    ->where('shop_id', $shop->id)
    ->where('snapshot_id', $latestSnapshot->id)
    ->whereBetween('create_time', [$currentPeriodStart, $currentPeriodEnd])
    ->select(DB::raw('MAX(id) as id'))
    ->groupBy('gbp_review_id')
    ->pluck('id');
```

**SQL相当:**
```sql
SELECT * FROM gbp_snapshots 
WHERE shop_id = ? 
ORDER BY synced_at DESC 
LIMIT 1;

SELECT MAX(id) as id FROM reviews 
WHERE shop_id = ? 
  AND snapshot_id = ? 
  AND create_time BETWEEN ? AND ?
GROUP BY gbp_review_id;
```

### 口コミ管理画面 (`ReviewsController::index`)

```php
// 重複を除外：同じshop_idとgbp_review_idの組み合わせで、最新のスナップショット（synced_atが最新）のもののみを表示
// GBPデータは共有なので、operator_idは関係ない
// まず、各shop_idごとに最新のスナップショットIDを取得
$latestSnapshotIds = DB::table('gbp_snapshots')
    ->select(DB::raw('MAX(id) as id'))
    ->groupBy('shop_id')
    ->pluck('id');

// 次に、そのスナップショットに紐づく口コミのうち、同じshop_idとgbp_review_idの組み合わせで最新のもののみを取得
$latestReviewIds = DB::table('reviews')
    ->whereIn('snapshot_id', $latestSnapshotIds)
    ->select(DB::raw('MAX(id) as id'))
    ->groupBy('shop_id', 'gbp_review_id')
    ->pluck('id');

$query->whereIn('id', $latestReviewIds);
```

**SQL相当:**
```sql
SELECT MAX(id) as id FROM gbp_snapshots 
GROUP BY shop_id;

SELECT MAX(id) as id FROM reviews 
WHERE snapshot_id IN (?)
GROUP BY shop_id, gbp_review_id;
```

### 質問への回答（③）

- **ログイン中ユーザーIDで絞っているか:**
  - ❌ **絞っていない**
  - すべて `shop_id` のみで取得
  - `synced_by_operator_id` や `user_id` での絞り込みは一切ない

- **直近同期分を全ユーザー共通で読んでいないか:**
  - ✅ **全ユーザー共通で最新スナップショットを読んでいる**
  - `GbpSnapshot::where('shop_id', $shop->id)->orderBy('synced_at', 'desc')->first()`
  - これは **最後に同期した人のスナップショット** を全員が見ることになる

- **「最後に同期した人の期間」が他ユーザーにも影響する設計になっていないか:**
  - ✅ **なっている**
  - 管理者が 2026-01-01〜2026-01-31 を同期 → スナップショットA作成
  - オペレーターが 2026-02-01〜2026-02-28 を同期 → スナップショットB作成（より新しい）
  - **全員がスナップショットB（2月データ）を見ることになる**
  - スナップショットA（1月データ）は表示されない

---

## ④ 再現シナリオでの検証

### シナリオ
1. 管理者(user_id=A, operator_id=null) が 2026-01-01〜2026-01-31 を同期
2. オペレーター(user_id=B, operator_id=1) が 2026-02-01〜2026-02-28 を同期

### 実際のDBの中身

#### `gbp_snapshots` テーブル
```
id | shop_id | synced_by_operator_id | synced_at           | sync_params
---|---------|----------------------|---------------------|------------------------------------------
1  | 2       | NULL                  | 2026-01-31 10:00:00 | {"start_date":"2026-01-01","end_date":"2026-01-31"}
2  | 2       | 1                     | 2026-02-28 10:00:00 | {"start_date":"2026-02-01","end_date":"2026-02-28"}
```

#### `reviews` テーブル
```
id | shop_id | snapshot_id | gbp_review_id | create_time | ...
---|---------|-------------|---------------|-------------|----
1  | 2       | 1           | "12345"       | 2026-01-15  | ... (1月の口コミ)
2  | 2       | 2           | "12345"       | 2026-01-15  | ... (同じ口コミ、別スナップショット)
3  | 2       | 2           | "67890"       | 2026-02-20  | ... (2月の口コミ)
```

### 質問への回答（④）

- **テーブルには A用の1月データとB用の2月データが両方残るか:**
  - ✅ **両方残る**
  - スナップショット1（管理者）: 1月の口コミが `snapshot_id=1` で保存
  - スナップショット2（オペレーター）: 1月+2月の口コミが `snapshot_id=2` で保存
  - **ただし、同じ `gbp_review_id` の口コミは両方のスナップショットに存在する可能性がある**

- **それともBの同期でAの期間やデータが上書きされるか:**
  - ❌ **上書きされない**
  - スナップショット1のデータは残る
  - ただし、**表示側では最新スナップショット（スナップショット2）のみが使われる**

- **管理者画面で A が見るデータはどれになるか:**
  - **スナップショット2（オペレーターが同期した2月データ）**
  - 理由: `GbpSnapshot::where('shop_id', $shop->id)->orderBy('synced_at', 'desc')->first()`
  - これは **最後に同期した人のスナップショット** を返すため

---

## ⑤ 結論（修正せずに事実だけ）

### 現状は「アカウント別に分離されている」か「上書き共有されている」か

**❌ アカウント別に分離されていない**
**✅ データは共有されている（ただし、上書きではなく追加保存）**

### それがどのコード・どのDBキーによって決まっているか

1. **保存時のキーにアカウントIDが含まれていない:**
   - `reviews`: `['snapshot_id', 'gbp_review_id']` のみ
   - `photos`: `['snapshot_id', 'gbp_media_id']` のみ
   - `gbp_snapshots`: `shop_id` のみ（`synced_by_operator_id` はログ用）

2. **表示側で最新スナップショットのみを取得:**
   ```php
   // すべての画面で同じロジック
   $latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
       ->orderBy('synced_at', 'desc')
       ->first();
   ```
   - `synced_by_operator_id` や `user_id` での絞り込みは一切ない
   - **最後に同期した人のスナップショット** が全員に表示される

3. **コメントに明記されている設計思想:**
   ```php
   // GBPデータは共有なので、operator_idは関係ない
   // GBPデータはSingle Source of Truthとして保存（operator_idは関係ない）
   ```
   - 意図的に「共有データ」として設計されている

### なぜ今、別ユーザーの同期が他の画面に反映されてしまうのか

**根本原因:**
1. **データ保存時:** アカウントIDで分離していない（`snapshot_id` のみで分離）
2. **データ取得時:** 最新スナップショットを全員が共有して表示
3. **結果:** 最後に同期した人のスナップショットが全員に表示される

**具体例:**
- 管理者が 1月を同期 → スナップショット1作成（synced_at: 2026-01-31 10:00）
- オペレーターが 2月を同期 → スナップショット2作成（synced_at: 2026-02-28 10:00）
- **全員がスナップショット2を見る** → 管理者もオペレーターが同期した2月データを見ることになる
- スナップショット1（1月データ）は表示されない

**設計上の問題点:**
- `synced_by_operator_id` はログ用のみで、データ分離には使われていない
- 表示側で `synced_by_operator_id` や `user_id` での絞り込みがない
- 「アカウント別同期」という要件と、実装の「共有データ」設計が矛盾している













