# 口コミ同期 分単位丸め修正レポート

## 修正内容

### 目的
Google API から返る `updateTime` と、DBに保存済みの `update_time` の比較で、秒やミリ秒等の差が原因で「同じ更新なのに毎回 `update_time_gt` 扱い」になる問題を解決する。

### 方針
比較前に「両方の時刻」を分単位に正規化してから判定する（秒以下をすべて0にする）。

### 実装内容

#### 1. 分単位丸め関数を追加

**実装箇所**: `app/Services/ReviewSyncService.php:26-35`

```php
/**
 * 時刻を分単位に丸める（秒以下をすべて0にする）
 * 例: 12:34:56 → 12:34:00
 * 
 * @param CarbonImmutable $time
 * @return CarbonImmutable
 */
private function roundToMinute(CarbonImmutable $time): CarbonImmutable
{
    return $time->copy()->startOfMinute();
}
```

**丸めの定義**: 分単位へ丸め = 秒以下をすべて 0 にする（例: 12:34:56 → 12:34:00）

#### 2. API側 updateTime を分単位に丸める

**修正箇所**: `app/Services/ReviewSyncService.php:166-170`

**修正前**:
```php
$apiTime = CarbonImmutable::parse($apiRaw, 'UTC')->utc();
```

**修正後**:
```php
$apiTime = CarbonImmutable::parse($apiRaw, 'UTC')->utc();
// 分単位に丸める（秒以下をすべて0にする）
$apiTime = $this->roundToMinute($apiTime);
```

#### 3. 既存側 update_time を分単位に丸める

**修正箇所**: `app/Services/ReviewSyncService.php:253-269`

**修正前**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    $existingTimeRaw = $existingRaw->format('Y-m-d H:i:s');
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
} else {
    $existingTimeRaw = (string)$existingRaw;
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
}
```

**修正後**:
```php
if ($existingRaw instanceof \Carbon\Carbon) {
    $existingTimeRaw = $existingRaw->format('Y-m-d H:i:s');
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
} else {
    $existingTimeRaw = (string)$existingRaw;
    $existingTime = CarbonImmutable::createFromFormat('Y-m-d H:i:s', $existingTimeRaw, 'UTC')->utc();
}
// 分単位に丸める（秒以下をすべて0にする）
$existingTime = $this->roundToMinute($existingTime);
```

**parse fallback も同様に修正**:
```php
$existingTime = CarbonImmutable::parse($existingRaw, 'UTC')->utc();
// 分単位に丸める（秒以下をすべて0にする）
$existingTime = $this->roundToMinute($existingTime);
```

#### 4. 判定ロジックのコメント更新

**修正箇所**: `app/Services/ReviewSyncService.php:280-283, 395-399`

**修正前**:
```php
// 判定: api_update_time <= existing_time なら SKIP、api_update_time > existing_time のときのみ UPSERT
// 比較は必ず CarbonImmutable(UTC) 同士で行う
if ($existingTime) {
    $shouldSkip = $apiTime->lessThanOrEqualTo($existingTime);
}
```

**修正後**:
```php
// 判定: api_min > existing_min なら更新、それ以外は更新不要
// 比較は必ず CarbonImmutable(UTC) 同士で行う（分単位に丸めた値で比較）
if ($existingTime) {
    $shouldSkip = $apiTime->lessThanOrEqualTo($existingTime);
}
```

**修正前**:
```php
// 判定: api_update_time > existing_time のときのみ UPSERT
if ($existingTime && $apiTime->greaterThan($existingTime)) {
    $hasChanges = true;
    $changeReasons[] = 'update_time_gt';
}
```

**修正後**:
```php
// 判定: api_min > existing_min のときのみ UPSERT（分単位に丸めた値で比較）
if ($existingTime && $apiTime->greaterThan($existingTime)) {
    $hasChanges = true;
    $changeReasons[] = 'update_time_gt';
}
```

#### 5. DB保存時の update_time も分単位に丸めた値を保存

**修正箇所**: `app/Services/ReviewSyncService.php:512`

**修正前**:
```php
'update_time' => $apiTime->format('Y-m-d H:i:s'), // updateTime が無い場合は createTime にフォールバック
```

**修正後**:
```php
'update_time' => $apiTime->format('Y-m-d H:i:s'), // 分単位に丸めた値（秒以下は00）
```

#### 6. ログに分単位の値を追加

**修正箇所**: `app/Services/ReviewSyncService.php:290-320, 405-432, 445-472`

**追加内容**:
```php
'api_min' => $apiTime->format('Y-m-d H:i:00'), // 分単位の値（ログ用）
'existing_min' => $existingTime ? $existingTime->format('Y-m-d H:i:00') : null, // 分単位の値（ログ用）
```

**コメント更新**:
```php
'api_update_time' => $apiTime->format('Y-m-d H:i:s'), // 比較に使った値から（分単位に丸めた値）
'existing_update_time' => $existingTime ? $existingTime->format('Y-m-d H:i:s') : null, // 比較に使った値から（分単位に丸めた値）
```

## 検証手順

### 1. 同期を実行

同一店舗で同期を2回連続実行

### 2. ログを確認

```bash
# REVIEWS_DIFF_DECISION ログを確認（api_min と existing_min が同一になることを確認）
grep "REVIEWS_DIFF_DECISION" storage/logs/laravel.log | tail -20

# ReviewSyncService: 口コミ同期完了 ログを確認
grep "ReviewSyncService: 口コミ同期完了" storage/logs/laravel.log | tail -10
```

### 3. 期待値（2回目同期）

**正常な場合（修正後）**:
- `updated_count`: 0（または極小）
- `skipped_count`: `fetched_count` に近い
- `api_min` と `existing_min` が同一になる
- 同じ `updateTime` が2回連続で来ても、2回目は更新判定にならない

**REVIEWS_DIFF_DECISION ログ（2回目同期、最初の3件）**:
```json
{
  "shop_id": 1,
  "gbp_review_id": "AbFv...",
  "api_update_time": "2025-12-24 01:39:00",  // 分単位に丸めた値（秒は00）
  "existing_update_time": "2025-12-24 01:39:00",  // 分単位に丸めた値（秒は00）
  "api_min": "2025-12-24 01:39:00",  // 分単位の値（ログ用）
  "existing_min": "2025-12-24 01:39:00",  // 分単位の値（ログ用）
  "api_ts": 1735012740,  // 分単位に丸めた値のtimestamp
  "existing_ts": 1735012740,  // 分単位に丸めた値のtimestamp（同値）
  "compare_api_lte_existing": true,
  "shouldSkip": true,
  "hasChanges": false,
  "decision": "SKIP",
  "reason": "update_time_lte_existing"
}
```

**ReviewSyncService: 口コミ同期完了（2回目）**:
```json
{
  "shop_id": 1,
  "fetched_count": 176,
  "rows_to_write_count": 0,
  "skipped_count": 176,
  "inserted_count": 0,
  "updated_count": 0,  // ← 0 になる
  "synced_count": 0
}
```

## 修正の効果

### 修正前

- APIの `updateTime` と DBの `update_time` が秒単位で異なる場合、毎回 `update_time_gt` 判定で全件UPDATEになる
- 例: API `2025-12-24 01:39:52` vs DB `2025-12-24 01:39:00` → 毎回更新される

### 修正後

- APIの `updateTime` と DBの `update_time` を分単位に丸めてから比較する
- 例: API `2025-12-24 01:39:52` → `2025-12-24 01:39:00` vs DB `2025-12-24 01:39:00` → 同一分なので更新されない
- 同じ `updateTime` が2回連続で来ても、2回目は更新判定にならない

## 完了条件

✅ 分単位丸め関数を追加（`roundToMinute`）  
✅ API側 updateTime を分単位に丸める  
✅ 既存側 update_time を分単位に丸める  
✅ 判定ロジックのコメント更新（api_min > existing_min）  
✅ DB保存時の update_time も分単位に丸めた値を保存  
✅ ログに分単位の値を追加（api_min, existing_min）  

**検証**: 上記の検証手順に従って、同じ `updateTime` が2回連続で来ても、2回目は更新判定にならないことを確認








