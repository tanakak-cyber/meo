# CompetitorAnalysis 修正設計案

## 目的
事実確認レポートを踏まえ、AI分析の論理破綻を防ぐための「最小・安全な修正設計案」を作成する。

**重要：このフェーズではコード修正・プロンプト変更は一切行わない。設計案と修正方針の整理のみ。**

---

## 優先度定義

- **P0（Critical）**: 論理破綻の直接原因となる問題。即座に修正が必要。
- **P1（High）**: 論理破綻の間接原因となる問題。早期に修正すべき。
- **P2（Medium）**: 将来の拡張性・保守性向上のための設計。中期的に対応。

---

## 【設計①】数値データの保証方針

### 優先度：P0（Critical）

### 現状の問題
- `normalize()`で数値型への変換が行われていない
- フロントエンドから送られてくる数値が文字列型（`"100"`）の場合、文字列比較になる可能性
- `0`と`__MISSING__`の区別がつかない

### 設計方針

#### 1. 数値項目の型保証ルール

**対象項目：**
- `review_count`（口コミ総数）
- `photo_count`（写真枚数）
- `video_count`（動画本数）

**保証方法：**
- `normalize()`メソッド内で、これらの項目を必ず`int`型に変換する
- 変換前の値が空文字・nullの場合は`__MISSING__`に変換（既存ロジック維持）
- 変換前の値が数値（文字列型の数値含む）の場合は`(int)`でキャスト

**実装方針（設計のみ）：**
```php
// normalize()内での処理設計
foreach ($shop as $key => $value) {
    // 数値項目の型保証
    if (in_array($key, ['review_count', 'photo_count', 'video_count'])) {
        if ($value === '' || $value === null) {
            $shop[$key] = '__MISSING__';
        } else {
            // 文字列型の数値も含めて int に変換
            $shop[$key] = (int)$value;
        }
        continue;
    }
    
    // その他の項目は既存ロジック
    if ($value === '' || $value === null) {
        $shop[$key] = '__MISSING__';
    }
}
```

#### 2. 0 と __MISSING__ の扱いルール

**意味の定義：**
- `0`（int型）：実際に0件であることを意味する（例：レビュー0件、写真0枚）
- `__MISSING__`（string型）：未設定・未入力であることを意味する（データが存在しない）

**AIへの伝達方法：**
- プロンプト内で明示：「`0`は実際に0件を意味し、`__MISSING__`は未設定を意味する」
- JSON内で`0`と`__MISSING__`を区別して渡す

**比較ルール：**
- `0`と`__MISSING__`は異なる意味を持つため、AIは区別して評価する
- `0`は「設定されているが0件」として評価
- `__MISSING__`は「未設定」として評価

#### 3. normalize() の責務範囲

**責務：**
1. データ型の正規化（数値項目を`int`型に変換）
2. 欠損値の正規化（空文字・nullを`__MISSING__`に変換）
3. `own_rank`の処理（ownのみ保持、他は削除）

**責務外：**
- データの妥当性チェック（バリデーションは別メソッドで実施）
- ビジネスロジックの適用（比較ロジックなど）

**設計原則：**
- `normalize()`は「データの形式を統一する」ことに専念
- データの意味解釈はAI側に委ねる（プロンプトで明示）

---

## 【設計②】比較ルールの明文化（プロンプト設計）

### 優先度：P0（Critical）

### 現状の問題
- 「自社が競合より優れている点は課題として出さない」というルールはあるが、数値的に明確でない
- 「多い」「少ない」の定義が数値的に明確でない

### 設計方針

#### 1. 数値比較ルールの明文化

**ルール定義：**

```
【数値比較ルール（絶対遵守・厳格適用）】

1. 数値項目（review_count, photo_count, video_count）の比較：
   - 自社の数値 > 競合の数値 → 「優れている」→ 順位低下の原因として使用禁止
   - 自社の数値 < 競合の数値 → 「劣っている」→ 順位低下の原因として使用可能
   - 自社の数値 = 競合の数値 → 「同等」→ 順位への影響は限定的と表現

2. 比較時の注意事項：
   - 数値は必ず数値型として比較すること（文字列比較禁止）
   - 0 と __MISSING__ は異なる意味を持つため、区別して評価すること
   - 自社が優れている項目を「不足」「課題」として表現することは禁止

3. 表現ルール：
   - 自社が優れている項目 → 「強み」「維持要因」として扱う
   - 自社が劣っている項目 → 「改善点」「順位低下の原因」として扱う
   - 同等の項目 → 「影響は限定的」と表現する
```

#### 2. 比較ルールの適用範囲

**適用対象：**
- `review_count`（口コミ総数）
- `photo_count`（写真枚数）
- `video_count`（動画本数）

**適用外（別ルール）：**
- `review_frequency`（頻度系データ → 設計③で定義）
- `post_frequency`（頻度系データ → 設計③で定義）
- `has_menu`、`has_video`など（有無系データ → 別ルール）

#### 3. プロンプト内での配置

**配置位置：**
- `buildPrompt()`内の「数値比較ルール」セクション（既存の414-424行目付近）
- 「比較ルール」セクション（既存の408-412行目付近）の直後に配置

**強調方法：**
- 「絶対遵守・厳格適用」という表現を使用
- 禁止事項を明示的に列挙
- 具体例を追加（例：自社100件 vs 競合50件の場合の扱い）

---

## 【設計③】頻度系データの比較ルール

### 優先度：P1（High）

### 現状の問題
- `post_frequency`の比較ルールが「頻度の強弱」とあるが、具体的な順序が明示されていない
- `review_frequency`の比較ルールが未定義

### 設計方針

#### 1. 頻度の序列定義

**頻度の強弱順序（強い順）：**

```
【頻度の強弱順序（厳格適用）】

1. 毎日
2. 週3回以上
3. 週1回
4. 月2回
5. 月1回
6. 不定期
7. なし / 未設定
```

**比較ルール：**
- 上位の頻度 > 下位の頻度
- 自社の頻度が競合より上位 → 「優れている」→ 順位低下の原因として使用禁止
- 自社の頻度が競合より下位 → 「劣っている」→ 順位低下の原因として使用可能
- 自社の頻度 = 競合の頻度 → 「同等」→ 順位への影響は限定的と表現

#### 2. 頻度データの正規化

**入力値のバリデーション：**
- フロントエンドから送られてくる値が上記の序列に含まれるかチェック
- 含まれない値の場合は「未設定」として扱う

**normalize()での処理：**
- 頻度データは文字列型のまま保持（序列比較のため）
- 空文字・nullの場合は`__MISSING__`に変換

#### 3. プロンプト内での明示

**配置位置：**
- `buildPrompt()`内の「数値比較ルール」セクションの直後に配置

**記載内容：**
```
【頻度比較ルール（絶対遵守）】

1. 頻度の強弱順序（強い順）：
   毎日 > 週3回以上 > 週1回 > 月2回 > 月1回 > 不定期 > なし/未設定

2. 比較ルール：
   - 自社の頻度が競合より上位 → 「優れている」→ 順位低下の原因として使用禁止
   - 自社の頻度が競合より下位 → 「劣っている」→ 順位低下の原因として使用可能
   - 自社の頻度 = 競合の頻度 → 「同等」→ 順位への影響は限定的と表現

3. 適用対象：
   - review_frequency（口コミ頻度）
   - post_frequency（投稿頻度）
```

---

## 【設計④】role判別の安全設計

### 優先度：P0（Critical）

### 現状の問題
- 複数の`role='own'`が存在する場合、最初の1つしか取得されない
- `role`フィールドが正しく設定されているかを検証するバリデーションが不十分

### 設計方針

#### 1. role='own' の存在保証

**保証方法：**
- `CompetitorAnalysisController::run()`内で、`role='own'`が必ず1件だけ存在することを検証
- 検証タイミング：バリデーション通過後、`normalize()`実行前

**検証ロジック（設計のみ）：**
```php
// バリデーション通過後、normalize()実行前
$ownShops = collect($validated['shops'])->where('role', 'own');
$ownCount = $ownShops->count();

if ($ownCount === 0) {
    // エラー：自社が存在しない
    return response()->json([
        'status' => 'error',
        'message' => '自社（role=own）の店舗データが存在しません。'
    ], 422);
}

if ($ownCount > 1) {
    // エラー：自社が複数存在する
    Log::error('[CompetitorAnalysis] Multiple own shops detected', [
        'count' => $ownCount,
        'shop_names' => $ownShops->pluck('shop_name')->toArray(),
    ]);
    return response()->json([
        'status' => 'error',
        'message' => '自社（role=own）の店舗データが複数存在します。1件のみ許可されています。'
    ], 422);
}
```

#### 2. role='competitor1' / 'competitor2' の扱い

**設計方針：**
- `competitor1`と`competitor2`は0件でも可（任意）
- 複数存在する場合は最初の1件のみ使用（警告ログを出力）

**検証ロジック（設計のみ）：**
```php
$competitor1Shops = collect($validated['shops'])->where('role', 'competitor1');
$competitor1Count = $competitor1Shops->count();

if ($competitor1Count > 1) {
    Log::warning('[CompetitorAnalysis] Multiple competitor1 shops detected', [
        'count' => $competitor1Count,
        'shop_names' => $competitor1Shops->pluck('shop_name')->toArray(),
    ]);
    // 最初の1件のみ使用（既存ロジック維持）
}
```

#### 3. エラー設計

**エラーレベル：**
- `role='own'`が0件 → **エラー（422）**：分析不可能
- `role='own'`が複数 → **エラー（422）**：分析不可能
- `role='competitor1'`が複数 → **警告（ログのみ）**：最初の1件を使用
- `role='competitor2'`が複数 → **警告（ログのみ）**：最初の1件を使用

**エラーメッセージ：**
- ユーザー向け：明確で分かりやすいメッセージ
- 開発者向け：詳細なログ出力（shop_name、countなど）

#### 4. バリデーション強化

**既存バリデーション：**
```php
'shops.*.role' => 'required|string|in:competitor1,competitor2,own',
```

**追加バリデーション（設計のみ）：**
- カスタムバリデーションルールを追加
- `shops`配列内で`role='own'`が必ず1件だけ存在することを検証

---

## 【設計⑤】AI出力の自己検証設計（将来対応）

### 優先度：P2（Medium）

### 現状の問題
- AIの出力結果を自動検証する仕組みがない
- `situation`フィールド内の文章をパースして数値比較の矛盾を検出する機能がない

### 設計方針

#### 1. 検証項目の定義

**検証対象：**
1. **数値比較の整合性**
   - `situation`フィールド内で「自社が競合より優れている項目」が「順位低下の原因」として記述されていないか
   - 例：自社の`review_count`が100件、競合が50件なのに「口コミが不足」と記述されていないか

2. **role判別の整合性**
   - `situation`フィールド内で「自社」と「競合」が正しく区別されているか
   - 例：競合の弱点を自社の順位低下理由として記述していないか

3. **論理の一貫性**
   - 前文と後文で矛盾がないか
   - 例：「ただし」「一方で」などの接続詞で前文と因果が逆転していないか

#### 2. 検証ロジックの設計

**検証タイミング：**
- `OpenAIService::analyzeCompetitor()`内で、AIの出力を取得した直後
- バリデーション通過前

**検証方法（設計のみ）：**
```php
private function validateAnalysisOutput(array $analysis, array $originalData): array
{
    $errors = [];
    $warnings = [];
    
    // 1. 数値比較の整合性チェック
    $ownShop = collect($originalData['shops'])->firstWhere('role', 'own');
    $competitor1Shop = collect($originalData['shops'])->firstWhere('role', 'competitor1');
    
    if ($ownShop && $competitor1Shop) {
        // review_countの比較
        $ownReviewCount = (int)($ownShop['review_count'] ?? 0);
        $comp1ReviewCount = (int)($competitor1Shop['review_count'] ?? 0);
        
        if ($ownReviewCount > $comp1ReviewCount) {
            // 自社が優れている場合、「不足」「課題」という表現が含まれていないかチェック
            $situation = $analysis['situation'] ?? '';
            if (preg_match('/口コミ.*不足|レビュー.*不足|口コミ.*課題|レビュー.*課題/', $situation)) {
                $errors[] = '数値比較の矛盾：自社のreview_countが競合より多いのに「不足」「課題」と記述されている';
            }
        }
    }
    
    // 2. role判別の整合性チェック
    // （実装は将来的に検討）
    
    // 3. 論理の一貫性チェック
    // （実装は将来的に検討）
    
    return [
        'errors' => $errors,
        'warnings' => $warnings,
    ];
}
```

#### 3. 不整合時の挙動設計

**エラーレベル：**
- **Critical Error（数値比較の矛盾）**：再生成を試みる or エラー返却
- **Warning（論理の一貫性）**：警告ログを出力し、そのまま返却

**再生成設計：**
- 不整合が検出された場合、プロンプトに「前回の出力に矛盾があった」という情報を追加して再生成
- 再生成回数は最大1回（無限ループ防止）

**エラー返却設計：**
- 再生成後も不整合が解消されない場合、エラーを返却
- エラーメッセージ：「分析結果に矛盾が検出されました。入力データを確認してください。」

#### 4. 実装優先度

**Phase 1（短期）：**
- 数値比較の整合性チェックのみ実装
- `review_count`、`photo_count`、`video_count`の3項目のみ

**Phase 2（中期）：**
- 頻度比較の整合性チェックを追加
- `review_frequency`、`post_frequency`の2項目

**Phase 3（長期）：**
- 論理の一貫性チェックを追加
- 自然言語処理による文章解析

---

## 実装優先度まとめ

### P0（Critical）- 即座に修正が必要
1. **数値データの保証方針**（設計①）
   - `normalize()`で数値項目を`int`型に変換
   - `0`と`__MISSING__`の区別を明確化

2. **比較ルールの明文化**（設計②）
   - プロンプト内で数値比較ルールを明示
   - 「優れている項目を課題として使用禁止」を強調

3. **role判別の安全設計**（設計④）
   - `role='own'`が必ず1件だけ存在することを検証
   - 複数存在時のエラー設計

### P1（High）- 早期に修正すべき
4. **頻度系データの比較ルール**（設計③）
   - 頻度の序列を定義
   - プロンプト内で頻度比較ルールを明示

### P2（Medium）- 中期的に対応
5. **AI出力の自己検証設計**（設計⑤）
   - 数値比較の整合性チェック
   - 論理の一貫性チェック

---

## 次のステップ

1. **設計レビュー**
   - 本設計案のレビューと承認
   - 優先度の再確認

2. **実装計画**
   - P0項目から順に実装
   - 各項目の実装スケジュール策定

3. **テスト計画**
   - 各項目のテストケース作成
   - 回帰テストの実施

---

## 注意事項

- **このフェーズでは一切の実装修正を行わない**
- 本設計案は「修正方針の整理」のみ
- 実装は別フェーズで実施












