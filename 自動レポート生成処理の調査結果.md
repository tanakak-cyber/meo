# 自動レポート生成処理の調査結果

## 1) 毎月3日の自動レポート生成処理のコード確認

### スケジュール設定
**ファイル**: `routes/console.php` (12-14行目)
```php
// 毎月3日の午前9時に前月分のレポートを自動送信
Schedule::command('reports:send-monthly')
    ->monthlyOn(3, '09:00')
    ->timezone('Asia/Tokyo');
```

### 実行コマンド
**ファイル**: `app/Console/Commands/SendMonthlyReports.php`
- **コマンド名**: `reports:send-monthly`
- **説明**: 月初1日に前月分のレポートPDFをメール送信

### データ取得方法
**ファイル**: `app/Console/Commands/SendMonthlyReports.php` の `generatePdf()` メソッド (194-332行目)

**重要な発見**:
- **直接APIを叩いていない** - DB保存済みデータのみを使用
- **スナップショットを考慮していない** - `GbpSnapshot` を取得していない
- **全スナップショットのデータが混在** - `snapshot_id` でフィルタリングしていない

**具体的なデータ取得箇所**:
```php
// 250-279行目: 口コミ・評価・返信率の計算
$currentReviewCount = $shop->reviews()
    ->whereBetween('create_time', [$currentPeriodStart, $currentPeriodEnd])
    ->count();
// → snapshot_id でフィルタリングしていない！

$currentRating = $shop->reviews()
    ->whereBetween('create_time', [$currentPeriodStart, $currentPeriodEnd])
    ->avg('rating');
// → snapshot_id でフィルタリングしていない！

$repliedReviews = $shop->reviews()
    ->whereBetween('create_time', [$currentPeriodStart, $currentPeriodEnd])
    ->whereNotNull('reply_text')
    ->count();
// → snapshot_id でフィルタリングしていない！
```

**写真数の計算**:
- 281-284行目: `$currentPhotoCount = 0;` とハードコードされており、実際には計算されていない

**投稿数**:
- 281行目: `$postCount = 0;` とハードコードされており、実際には計算されていない

---

## 2) レポート生成前に「自動同期処理」は実行されているか？

### 結論: **NO（実行されていない）**

**根拠**:
- `routes/console.php` には `reports:send-monthly` コマンドのみがスケジュールされている
- 同期処理（`ReportController::sync()` や `ReportController::syncAll()`）を呼び出すコマンドは存在しない
- `SendMonthlyReports::handle()` メソッド内でも同期処理は呼ばれていない

**同期処理の実行箇所**:
- `ReportController::sync()` - 手動で「同期ボタン」を押したときのみ実行
- `ReportController::syncAll()` - 手動で「全店舗同期」を実行したときのみ実行

---

## 3) 仮に店舗が1ヶ月間「同期ボタンを押していなかった場合」、レポートはどのデータを元に生成されるか？

### 結論: **最後に同期された時点のデータ（古い値）が使用される**

**根拠**:
- `SendMonthlyReports::generatePdf()` では、`$shop->reviews()` と `$shop->photos()` を直接呼び出している
- これらのリレーションは `snapshot_id` でフィルタリングしていないため、**全スナップショットのデータが混在**している
- ただし、`create_time` で期間フィルタリングしているため、該当期間内のデータは取得される
- 問題は、**同じ口コミが複数のスナップショットに含まれている場合、重複カウントされる可能性がある**

**具体例**:
- 1月1日に同期 → スナップショットA作成（口コミ10件）
- 1月15日に同期 → スナップショットB作成（口コミ15件、うち10件はスナップショットAと重複）
- 2月3日に自動レポート生成 → **口コミ数は15件としてカウントされる（重複あり）**

**さらに問題な点**:
- `ReportController::show()` では `latestSnapshot` を取得して `snapshot_id` でフィルタリングしているが、`SendMonthlyReports::generatePdf()` ではその処理がない
- つまり、**自動レポートと手動レポートでデータの取得方法が異なる**

---

## 4) 現在の設計だと、「同期されていない状態で自動レポートが送られる」可能性はありますか？

### 結論: **YES（確実に発生する）**

**根拠となるコード箇所**:

1. **スケジュール設定** (`routes/console.php` 12-14行目):
   - 毎月3日に自動実行される
   - 同期処理は呼ばれない

2. **レポート生成処理** (`app/Console/Commands/SendMonthlyReports.php` 98行目):
   ```php
   $pdfData = $this->generatePdf($shop, $from, $to);
   ```
   - 同期処理を呼ばずに直接PDF生成

3. **データ取得処理** (`app/Console/Commands/SendMonthlyReports.php` 250-279行目):
   ```php
   $currentReviewCount = $shop->reviews()
       ->whereBetween('create_time', [$currentPeriodStart, $currentPeriodEnd])
       ->count();
   ```
   - DBに保存されているデータを直接取得
   - 最新性のチェックなし
   - 同期日時の確認なし

4. **同期処理の実行箇所** (`app/Http/Controllers/ReportController.php`):
   - `sync()` メソッド (686-825行目) - 手動実行のみ
   - `syncAll()` メソッド (499-684行目) - 手動実行のみ
   - 自動実行されるコマンドは存在しない

**結論**: 
- 同期ボタンを1ヶ月間押さなかった場合、**最後に同期された時点のデータ（古い値）がレポートに含まれる**
- さらに、**全スナップショットのデータが混在しているため、重複カウントの可能性もある**

---

## 5) 改善案

### 改善案1: レポート生成前に自動同期を挟む設計（推奨）

**実装方針**:
1. `SendMonthlyReports::handle()` の冒頭で、対象店舗に対して自動同期を実行
2. 同期処理は `ReportController::syncAll()` のロジックを再利用
3. 同期完了後にレポート生成

**メリット**:
- 常に最新データでレポート生成
- 手動同期の負担を軽減

**デメリット**:
- レポート生成に時間がかかる（API呼び出しのため）
- APIレート制限に注意が必要

**実装例**:
```php
// SendMonthlyReports::handle() の冒頭に追加
foreach ($shops as $shop) {
    // 自動同期処理
    $googleService = new GoogleBusinessProfileService();
    $accessToken = $googleService->getAccessToken($shop);
    
    if ($accessToken) {
        $snapshot = GbpSnapshot::create([...]);
        $this->syncReviews($shop, $accessToken, $googleService, $snapshot->id);
        $this->syncPhotos($shop, $accessToken, $googleService, $snapshot->id);
        // ...
    }
}
```

---

### 改善案2: 同期が古い場合はレポート生成を止める設計

**実装方針**:
1. 最新のスナップショットの `synced_at` を確認
2. 前月の最終日時点で、最新のスナップショットが存在しない、または古すぎる場合はスキップ
3. スキップした店舗はログに記録

**メリット**:
- 古いデータでレポートを送ることを防止
- 実装が簡単

**デメリット**:
- 同期されていない店舗はレポートが送られない
- 顧客への説明が必要

**実装例**:
```php
// SendMonthlyReports::handle() 内で各店舗を処理する前に追加
$latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
    ->orderBy('synced_at', 'desc')
    ->first();

if (!$latestSnapshot || $latestSnapshot->synced_at->lt($prevPeriodEnd)) {
    $this->warn("スキップ: {$shop->name} (最新の同期が前月以前)");
    Log::warning('MONTHLY_REPORT_SKIPPED_OLD_SYNC', [
        'shop_id' => $shop->id,
        'shop_name' => $shop->name,
        'latest_sync' => $latestSnapshot?->synced_at,
        'prev_period_end' => $prevPeriodEnd,
    ]);
    continue;
}
```

---

### 改善案3: 同期日時をレポートに明示する設計

**実装方針**:
1. 最新のスナップショットの `synced_at` を取得
2. PDFのヘッダーまたはフッターに「最終同期日時: YYYY-MM-DD HH:MM」を表示
3. 同期が古い場合は警告メッセージを表示

**メリット**:
- レポートの信頼性が向上
- 顧客がデータの新しさを確認できる

**デメリット**:
- 根本的な解決にはならない（古いデータが使われる問題は残る）

**実装例**:
```php
// SendMonthlyReports::generatePdf() 内で
$latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
    ->orderBy('synced_at', 'desc')
    ->first();

$lastSyncedAt = $latestSnapshot?->synced_at;
$isSyncOld = $lastSyncedAt && $lastSyncedAt->lt($prevPeriodEnd);

// PDFテンプレートに渡す
$html = view('reports.pdf', compact(
    'shop',
    'lastSyncedAt',
    'isSyncOld',
    // ...
))->render();
```

---

### 改善案4: スナップショットベースのデータ取得に統一（最重要）

**実装方針**:
1. `SendMonthlyReports::generatePdf()` を `ReportController::show()` と同じロジックに統一
2. 最新のスナップショットを取得
3. `snapshot_id` でフィルタリングしてデータを取得
4. 重複排除処理を追加（`gbp_review_id` や `gbp_media_id` でユニーク化）

**メリット**:
- 手動レポートと自動レポートでデータが一致
- 重複カウントの問題を解決

**デメリット**:
- コードの重複が発生（DRY原則に反する）
- リファクタリングが必要

**実装例**:
```php
// SendMonthlyReports::generatePdf() を修正
// 最新のスナップショットを取得（ユーザー別に分離しない、自動レポート用）
$latestSnapshot = GbpSnapshot::where('shop_id', $shop->id)
    ->orderBy('synced_at', 'desc')
    ->first();

if ($latestSnapshot) {
    // スナップショットベースでデータ取得（ReportController::show() と同じロジック）
    $currentReviewIds = DB::table('reviews')
        ->where('shop_id', $shop->id)
        ->where('snapshot_id', $latestSnapshot->id)
        ->whereBetween('create_time', [...])
        ->select(DB::raw('MAX(id) as id'))
        ->groupBy('gbp_review_id')
        ->pluck('id');
    
    $currentReviewCount = count($currentReviewIds);
    // ...
} else {
    // スナップショットが存在しない場合は0
    $currentReviewCount = 0;
    // ...
}
```

---

## まとめ

### 現在の問題点

1. **自動同期処理が存在しない**
   - レポート生成前に同期処理が実行されない
   - 古いデータでレポートが生成される可能性が高い

2. **スナップショットを考慮していない**
   - 全スナップショットのデータが混在
   - 重複カウントの可能性

3. **手動レポートと自動レポートでデータ取得方法が異なる**
   - 手動: `latestSnapshot` を使用して `snapshot_id` でフィルタリング
   - 自動: スナップショットを考慮せず、全データから取得

4. **写真数・投稿数が計算されていない**
   - ハードコードで `0` が設定されている

### 推奨される改善順序

1. **最優先**: 改善案4（スナップショットベースのデータ取得に統一）
2. **次**: 改善案1（レポート生成前に自動同期）または 改善案2（古い同期の場合はスキップ）
3. **補完**: 改善案3（同期日時をレポートに明示）









