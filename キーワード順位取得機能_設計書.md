# オペレーター手動トリガー型キーワード順位取得機能 設計書

## 目的
Googleにブロックされず、APIコストゼロで、オペレーターが自分の担当店舗の順位を取得できる構造を作る。

---

## ① 権限とスコープ設計

### 権限チェックの実装箇所

#### 1. ルート定義（`routes/web.php`）

**オペレーター用ルート**:
```php
Route::middleware('operator.auth')->prefix('operator')->name('operator.')->group(function () {
    // キーワード順位取得トリガー
    Route::post('/shops/{shop}/fetch-ranks', [ShopController::class, 'fetchRanks'])
        ->name('shops.fetch-ranks');
});
```

**管理者用ルート**:
```php
Route::middleware(['auth', 'admin.only'])->group(function () {
    Route::post('/shops/{shop}/fetch-ranks', [ShopController::class, 'fetchRanks'])
        ->name('shops.fetch-ranks');
});
```

#### 2. コントローラーでの権限チェック（`app/Http/Controllers/ShopController.php`）

```php
public function fetchRanks(Request $request, Shop $shop)
{
    $user = Auth::user();
    $operatorId = session('operator_id');
    
    // オペレーターの場合は担当店舗チェック
    if (!$user || !$user->is_admin) {
        // operator_shopsテーブルを優先チェック
        $isAssigned = \App\Models\OperatorShop::where('operator_id', $operatorId)
            ->where('shop_id', $shop->id)
            ->exists();
        
        // フォールバック: operation_person_id
        if (!$isAssigned) {
            $isAssigned = $shop->operation_person_id == $operatorId;
        }
        
        if (!$isAssigned) {
            abort(403, 'この店舗の順位取得権限がありません');
        }
    }
    
    // 権限チェック通過後の処理...
}
```

#### 3. APIエンドポイントでの権限チェック（`routes/api.php`）

```php
Route::middleware(['auth:sanctum'])->group(function () {
    Route::post('/rank-log', [Api\RankLogController::class, 'store']);
});
```

**API側の権限チェック**:
```php
// app/Http/Controllers/Api/RankLogController.php
public function store(Request $request)
{
    $user = Auth::user();
    $shopId = $request->input('shop_id');
    $meoKeywordId = $request->input('meo_keyword_id');
    
    // shop_idとmeo_keyword_idの整合性チェック
    $keyword = MeoKeyword::findOrFail($meoKeywordId);
    if ($keyword->shop_id != $shopId) {
        abort(400, 'Invalid shop_id and meo_keyword_id combination');
    }
    
    // オペレーターの場合は担当店舗チェック
    if (!$user->is_admin) {
        $operatorId = $user->operator_id ?? session('operator_id');
        $isAssigned = \App\Models\OperatorShop::where('operator_id', $operatorId)
            ->where('shop_id', $shopId)
            ->exists();
        
        if (!$isAssigned) {
            $shop = Shop::findOrFail($shopId);
            $isAssigned = $shop->operation_person_id == $operatorId;
        }
        
        if (!$isAssigned) {
            abort(403, 'この店舗の順位保存権限がありません');
        }
    }
    
    // 順位データ保存...
}
```

### 使用テーブル

- **`operator_shops`**: オペレーターと店舗の明示的な紐付け（優先）
- **`shops.operation_person_id`**: フォールバック用の暗黙的紐付け
- **`users.is_admin`**: 管理者フラグ

### ミドルウェア

- **`operator.auth`**: オペレーター認証（セッションベース）
- **`auth:sanctum`**: API認証（トークンベース）

---

## ② フロントUI設計

### 配置画面

**対象**: `resources/views/shops/show.blade.php`

**配置位置**: MEOキーワード表示セクション（592-603行目付近）の直下

### UI実装

```blade
{{-- MEOキーワードセクション --}}
<div>
    <dt class="text-sm font-medium text-gray-500">MEOキーワード</dt>
    <dd class="mt-1 text-sm text-gray-900">
        @if($shop->meoKeywords->count() > 0)
            <ul class="list-disc list-inside space-y-1">
                @foreach($shop->meoKeywords as $keyword)
                    <li>{{ $keyword->keyword }}</li>
                @endforeach
            </ul>
            
            {{-- キーワード順位取得ボタン --}}
            <div class="mt-3">
                <button 
                    type="button"
                    id="fetch-ranks-btn"
                    class="inline-flex items-center px-4 py-2 bg-blue-600 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-blue-700 active:bg-blue-900 focus:outline-none focus:border-blue-900 focus:ring ring-blue-300 disabled:opacity-25 transition ease-in-out duration-150"
                    onclick="fetchRanks({{ $shop->id }})"
                >
                    <span id="fetch-ranks-text">キーワード順位を取得</span>
                    <svg id="fetch-ranks-spinner" class="hidden ml-2 h-4 w-4 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </div>
        @else
            未設定
        @endif
    </dd>
</div>
```

### JavaScript実装（AJAX）

```javascript
async function fetchRanks(shopId) {
    const btn = document.getElementById('fetch-ranks-btn');
    const text = document.getElementById('fetch-ranks-text');
    const spinner = document.getElementById('fetch-ranks-spinner');
    
    // ボタンを無効化
    btn.disabled = true;
    text.textContent = '取得中...';
    spinner.classList.remove('hidden');
    
    try {
        const response = await fetch(`/operator/shops/${shopId}/fetch-ranks`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content,
            },
            body: JSON.stringify({}),
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // 成功メッセージ表示
            alert(`順位取得を開始しました。\n処理ID: ${data.job_id}\n完了まで数分かかる場合があります。`);
            
            // ポーリングで進捗確認（オプション）
            pollJobStatus(data.job_id);
        } else {
            alert(`エラー: ${data.message || '順位取得に失敗しました'}`);
        }
    } catch (error) {
        console.error('Error:', error);
        alert('順位取得リクエストに失敗しました');
    } finally {
        // ボタンを再有効化
        btn.disabled = false;
        text.textContent = 'キーワード順位を取得';
        spinner.classList.add('hidden');
    }
}

// 進捗確認（オプション）
async function pollJobStatus(jobId) {
    // 実装は省略（必要に応じて追加）
}
```

### 進捗表示

**方式**: モーダルまたはトースト通知

**実装例**:
```javascript
// 成功時: トースト通知
toast.success('順位取得を開始しました。完了まで数分かかる場合があります。');

// エラー時: アラート
alert('エラー: ' + errorMessage);
```

---

## ③ Laravel API設計

### エンドポイント定義

**ファイル**: `routes/api.php`（新規作成または既存）

```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\Api\RankLogController;

Route::middleware(['auth:sanctum'])->group(function () {
    Route::post('/rank-log', [RankLogController::class, 'store']);
});
```

### 認証方法

**Laravel Sanctum を使用**

**理由**:
- セッション認証とAPIトークン認証の両方をサポート
- 既存のセッション認証と共存可能
- CSRF保護が不要（トークンベース）

**実装**:
```php
// app/Http/Controllers/Api/RankLogController.php
use Illuminate\Support\Facades\Auth;

public function store(Request $request)
{
    // Sanctumトークンで認証済み
    $user = Auth::user();
    
    // 権限チェック（①で設計した通り）
    // ...
}
```

### CSRF回避

**方法**: Sanctumのトークンベース認証を使用

**理由**:
- APIエンドポイントはCSRF保護の対象外
- トークンベース認証でセキュリティを確保

### なりすまし防止

**実装**:
1. **トークン発行時の制限**:
   ```php
   // Node.js側に発行するトークンは「rank-log API専用」に制限
   $token = $user->createToken('rank-log-api', ['rank-log:write'])->plainTextToken;
   ```

2. **リクエスト検証**:
   ```php
   // shop_idとmeo_keyword_idの整合性チェック
   $keyword = MeoKeyword::findOrFail($meoKeywordId);
   if ($keyword->shop_id != $shopId) {
       abort(400, 'Invalid combination');
   }
   ```

3. **権限チェック**:
   ```php
   // オペレーターは自分の担当店舗のみ
   // （①で設計した通り）
   ```

### 1オペレーター1ジョブ制限

**実装方法**: データベースロック + ジョブキュー

```php
// app/Http/Controllers/ShopController.php
public function fetchRanks(Request $request, Shop $shop)
{
    // 権限チェック...
    
    // 既存の実行中ジョブをチェック
    $existingJob = \Illuminate\Support\Facades\DB::table('rank_fetch_jobs')
        ->where('shop_id', $shop->id)
        ->where('status', 'processing')
        ->where('created_at', '>', now()->subMinutes(10)) // 10分以内のジョブ
        ->first();
    
    if ($existingJob) {
        return response()->json([
            'error' => '既に順位取得が実行中です。完了までお待ちください。',
            'job_id' => $existingJob->id,
        ], 409);
    }
    
    // ジョブをキューに投入
    $jobId = \Illuminate\Support\Facades\DB::table('rank_fetch_jobs')->insertGetId([
        'shop_id' => $shop->id,
        'user_id' => Auth::id() ?? null,
        'operator_id' => session('operator_id'),
        'status' => 'queued',
        'created_at' => now(),
        'updated_at' => now(),
    ]);
    
    // Node.jsにジョブを通知（HTTPリクエストまたはキュー）
    \App\Jobs\NotifyRankFetchJob::dispatch($shop->id, $jobId);
    
    return response()->json([
        'message' => '順位取得を開始しました',
        'job_id' => $jobId,
    ]);
}
```

**テーブル設計**:
```sql
CREATE TABLE rank_fetch_jobs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    shop_id BIGINT NOT NULL,
    user_id BIGINT NULL,
    operator_id BIGINT NULL,
    status ENUM('queued', 'processing', 'completed', 'failed') NOT NULL,
    error_message TEXT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    INDEX idx_shop_status (shop_id, status, created_at)
);
```

---

## ④ Node.js側の役割

### フロー設計

```
1. Laravel → Node.js: ジョブ通知
   POST http://localhost:3000/api/fetch-ranks
   {
     "job_id": 123,
     "shop_id": 456,
     "keywords": [
       { "id": 1, "keyword": "渋谷 外壁塗装" },
       { "id": 2, "keyword": "渋谷 リフォーム" }
     ],
     "shop_name": "○○塗装店",
     "gbp_url": "https://www.google.com/maps/place/..."
   }

2. Node.js: PlaywrightでGoogle検索
   - 各キーワードで検索
   - 店舗名 or GBP URLでヒット順位を特定
   - 1位〜10位をチェック

3. Node.js → Laravel: 結果をPOST
   POST http://localhost:8000/api/rank-log
   Authorization: Bearer {sanctum_token}
   {
     "shop_id": 456,
     "meo_keyword_id": 1,
     "rank": 3,
     "checked_at": "2026-02-02"
   }
   (各キーワードごとにPOST)

4. Node.js → Laravel: ジョブ完了通知
   PATCH http://localhost:8000/api/rank-fetch-jobs/{job_id}
   {
     "status": "completed"
   }
```

### Node.js実装（概要）

```javascript
// server.js
const express = require('express');
const { chromium } = require('playwright');
const axios = require('axios');

const app = express();
app.use(express.json());

// Laravelからジョブを受信
app.post('/api/fetch-ranks', async (req, res) => {
    const { job_id, shop_id, keywords, shop_name, gbp_url } = req.body;
    
    try {
        // 各キーワードの順位を取得
        for (const keywordData of keywords) {
            const rank = await fetchGoogleRank(keywordData.keyword, shop_name, gbp_url);
            
            // Laravel APIに結果をPOST
            await axios.post('http://localhost:8000/api/rank-log', {
                shop_id,
                meo_keyword_id: keywordData.id,
                rank: rank || null, // 10位以下はnull
                checked_at: new Date().toISOString().split('T')[0],
            }, {
                headers: {
                    'Authorization': `Bearer ${process.env.LARAVEL_API_TOKEN}`,
                    'Content-Type': 'application/json',
                },
            });
        }
        
        // ジョブ完了通知
        await axios.patch(`http://localhost:8000/api/rank-fetch-jobs/${job_id}`, {
            status: 'completed',
        }, {
            headers: {
                'Authorization': `Bearer ${process.env.LARAVEL_API_TOKEN}`,
            },
        });
        
        res.json({ success: true });
    } catch (error) {
        console.error('Error:', error);
        // エラー通知
        await axios.patch(`http://localhost:8000/api/rank-fetch-jobs/${job_id}`, {
            status: 'failed',
            error_message: error.message,
        });
        res.status(500).json({ error: error.message });
    }
});

async function fetchGoogleRank(keyword, shopName, gbpUrl) {
    const browser = await chromium.launch({ headless: false });
    const page = await browser.newPage();
    
    try {
        // Google検索
        await page.goto(`https://www.google.com/search?q=${encodeURIComponent(keyword)}`);
        await page.waitForTimeout(3000); // 読み込み待機
        
        // 検索結果から店舗名 or GBP URLでヒット順位を特定
        const results = await page.$$eval('div.g', (elements, targetName, targetUrl) => {
            return elements.map((el, index) => {
                const link = el.querySelector('a');
                const url = link ? link.href : '';
                const title = el.querySelector('h3')?.textContent || '';
                return { rank: index + 1, url, title };
            }).filter(r => 
                r.title.includes(targetName) || 
                r.url.includes(targetUrl)
            );
        }, shopName, gbpUrl);
        
        return results.length > 0 ? results[0].rank : null;
    } finally {
        await browser.close();
    }
}

app.listen(3000, () => {
    console.log('Node.js server running on port 3000');
});
```

---

## ⑤ 並列・安全性

### 同時に複数ボタンを押された場合

**対策1: フロントエンド側**
```javascript
let isFetching = false;

async function fetchRanks(shopId) {
    if (isFetching) {
        alert('既に順位取得が実行中です');
        return;
    }
    
    isFetching = true;
    try {
        // リクエスト送信...
    } finally {
        isFetching = false;
    }
}
```

**対策2: バックエンド側（③で設計した通り）**
- `rank_fetch_jobs`テーブルで実行中ジョブをチェック
- 10分以内の`processing`ジョブがあれば409エラーを返す

### 同じ店舗を2人が同時に計測した場合

**対策: データベースロック**

```php
// app/Http/Controllers/ShopController.php
public function fetchRanks(Request $request, Shop $shop)
{
    // トランザクション + ロック
    return \Illuminate\Support\Facades\DB::transaction(function () use ($shop) {
        // 行ロックで同時実行を防ぐ
        $existingJob = \Illuminate\Support\Facades\DB::table('rank_fetch_jobs')
            ->where('shop_id', $shop->id)
            ->where('status', 'processing')
            ->where('created_at', '>', now()->subMinutes(10))
            ->lockForUpdate() // 行ロック
            ->first();
        
        if ($existingJob) {
            abort(409, '既に順位取得が実行中です');
        }
        
        // ジョブ作成...
    });
}
```

### その他の安全性対策

1. **レート制限**:
   ```php
   // 1オペレーターあたり1時間に10回まで
   RateLimiter::for('fetch-ranks', function ($request) {
       return Limit::perHour(10)->by($request->user()->id ?? session('operator_id'));
   });
   ```

2. **タイムアウト**:
   ```php
   // Node.js側で30秒タイムアウト
   const controller = new AbortController();
   const timeoutId = setTimeout(() => controller.abort(), 30000);
   ```

3. **リトライ**:
   ```php
   // 失敗時は3回までリトライ（指数バックオフ）
   ```

---

## ⑥ ゴール: 5000店舗 × 毎日 × 人手で安全に回る設計

### 設計の妥当性

**✅ 実現可能な理由**:

1. **手動トリガー**:
   - オペレーターがボタンを押す = 人間の操作
   - Googleの自動化検出を回避（人間の操作として認識される）

2. **並列実行制限**:
   - 1店舗あたり10分に1回まで
   - 1オペレーターあたり1時間に10回まで
   - データベースロックで同時実行を防止

3. **スケーラビリティ**:
   - 5000店舗 × 10キーワード = 50,000クエリ/日
   - 1オペレーターが1日10店舗処理 = 500オペレーター必要
   - **現実的には**: 1オペレーターが1日50店舗処理 = 100オペレーターで対応可能

4. **コスト**:
   - APIコスト: **ゼロ**（スクレイピングのみ）
   - サーバーコスト: Node.jsサーバー1台で十分（手動トリガーのため負荷分散不要）

5. **安全性**:
   - 手動操作のためGoogleブロックリスクが低い
   - レート制限で過剰リクエストを防止
   - エラーハンドリングで異常終了を防止

### ボトルネック分析

**想定ボトルネック**:
- **Node.jsサーバーの処理能力**: 1リクエストあたり30秒（10キーワード × 3秒/キーワード）
- **同時実行数**: 最大10並列（Node.jsサーバー1台で十分）

**対策**:
- 必要に応じてNode.jsサーバーをスケールアウト
- キューイングシステム（Redis + Bull）でジョブ管理

### 結論

**✅ この設計は「5000店舗 × 毎日 × 人手で安全に回る」要件を満たす**

**根拠**:
1. 手動トリガーでGoogleブロックを回避
2. 並列実行制限で安全性を確保
3. スケーラブルなアーキテクチャ
4. コストゼロ（API不要）
5. エラーハンドリングとリトライ機能

---

## 実装時の注意点

1. **Node.jsサーバーの起動**: WindowsサービスまたはPM2で常駐化
2. **トークン管理**: Sanctumトークンは環境変数で管理
3. **ログ**: すべてのリクエストとエラーをログに記録
4. **監視**: ジョブの実行状況をダッシュボードで監視
5. **テスト**: 小規模でテストしてから本番投入














